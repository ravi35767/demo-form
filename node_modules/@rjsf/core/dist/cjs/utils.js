"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canExpand = canExpand;
exports.getDefaultRegistry = getDefaultRegistry;
exports.getSchemaType = getSchemaType;
exports.getWidget = getWidget;
exports.hasWidget = hasWidget;
exports.getDefaultFormState = getDefaultFormState;
exports.mergeDefaultsWithFormData = mergeDefaultsWithFormData;
exports.getUiOptions = getUiOptions;
exports.getDisplayLabel = getDisplayLabel;
exports.isObject = isObject;
exports.mergeObjects = mergeObjects;
exports.asNumber = asNumber;
exports.orderProperties = orderProperties;
exports.isConstant = isConstant;
exports.toConstant = toConstant;
exports.isSelect = isSelect;
exports.isMultiSelect = isMultiSelect;
exports.isFilesArray = isFilesArray;
exports.isFixedItems = isFixedItems;
exports.allowAdditionalItems = allowAdditionalItems;
exports.optionsList = optionsList;
exports.findSchemaDefinition = findSchemaDefinition;
exports.stubExistingAdditionalProperties = stubExistingAdditionalProperties;
exports.resolveSchema = resolveSchema;
exports.retrieveSchema = retrieveSchema;
exports.mergeSchemas = mergeSchemas;
exports.deepEquals = deepEquals;
exports.shouldRender = shouldRender;
exports.toIdSchema = toIdSchema;
exports.toPathSchema = toPathSchema;
exports.parseDateString = parseDateString;
exports.toDateString = toDateString;
exports.utcToLocal = utcToLocal;
exports.localToUTC = localToUTC;
exports.pad = pad;
exports.dataURItoBlob = dataURItoBlob;
exports.rangeSpec = rangeSpec;
exports.getMatchingOption = getMatchingOption;
exports.schemaRequiresTrueValue = schemaRequiresTrueValue;
exports.guessType = exports.ADDITIONAL_PROPERTY_FLAG = void 0;

var _react = _interopRequireDefault(require("react"));

var ReactIs = _interopRequireWildcard(require("react-is"));

var _jsonSchemaMergeAllof = _interopRequireDefault(require("json-schema-merge-allof"));

var _fill = _interopRequireDefault(require("core-js-pure/features/array/fill"));

var _union = _interopRequireDefault(require("lodash/union"));

var _jsonpointer = _interopRequireDefault(require("jsonpointer"));

var _fields = _interopRequireDefault(require("./components/fields"));

var _widgets = _interopRequireDefault(require("./components/widgets"));

var _validate = _interopRequireWildcard(require("./validate"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var ADDITIONAL_PROPERTY_FLAG = "__additional_property";
exports.ADDITIONAL_PROPERTY_FLAG = ADDITIONAL_PROPERTY_FLAG;
var widgetMap = {
  "boolean": {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};

function canExpand(schema, uiSchema, formData) {
  if (!schema.additionalProperties) {
    return false;
  }

  var _getUiOptions = getUiOptions(uiSchema),
      expandable = _getUiOptions.expandable;

  if (expandable === false) {
    return expandable;
  } // if ui:options.expandable was not explicitly set to false, we can add
  // another property if we have not exceeded maxProperties yet


  if (schema.maxProperties !== undefined) {
    return Object.keys(formData).length < schema.maxProperties;
  }

  return true;
}

function getDefaultRegistry() {
  return {
    fields: _fields["default"],
    widgets: _widgets["default"],
    definitions: {},
    rootSchema: {},
    formContext: {}
  };
}
/* Gets the type of a given schema. */


function getSchemaType(schema) {
  var type = schema.type;

  if (!type && schema["const"]) {
    return guessType(schema["const"]);
  }

  if (!type && schema["enum"]) {
    return "string";
  }

  if (!type && (schema.properties || schema.additionalProperties)) {
    return "object";
  }

  if (type instanceof Array && type.length === 2 && type.includes("null")) {
    return type.find(function (type) {
      return type !== "null";
    });
  }

  return type;
}

function getWidget(schema, widget) {
  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var type = getSchemaType(schema);

  function mergeOptions(Widget) {
    // cache return value as property of widget for proper react reconciliation
    if (!Widget.MergedWidget) {
      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};

      Widget.MergedWidget = function (_ref) {
        var _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            props = _objectWithoutProperties(_ref, ["options"]);

        return _react["default"].createElement(Widget, _extends({
          options: _objectSpread({}, defaultOptions, options)
        }, props));
      };
    }

    return Widget.MergedWidget;
  }

  if (typeof widget === "function" || ReactIs.isForwardRef(_react["default"].createElement(widget)) || ReactIs.isMemo(widget)) {
    return mergeOptions(widget);
  }

  if (typeof widget !== "string") {
    throw new Error("Unsupported widget definition: ".concat(_typeof(widget)));
  }

  if (registeredWidgets.hasOwnProperty(widget)) {
    var registeredWidget = registeredWidgets[widget];
    return getWidget(schema, registeredWidget, registeredWidgets);
  }

  if (!widgetMap.hasOwnProperty(type)) {
    throw new Error("No widget for type \"".concat(type, "\""));
  }

  if (widgetMap[type].hasOwnProperty(widget)) {
    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];
    return getWidget(schema, _registeredWidget, registeredWidgets);
  }

  throw new Error("No widget \"".concat(widget, "\" for type \"").concat(type, "\""));
}

function hasWidget(schema, widget) {
  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  try {
    getWidget(schema, widget, registeredWidgets);
    return true;
  } catch (e) {
    if (e.message && (e.message.startsWith("No widget") || e.message.startsWith("Unsupported widget"))) {
      return false;
    }

    throw e;
  }
}

function computeDefaults(_schema, parentDefaults, rootSchema) {
  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var schema = isObject(_schema) ? _schema : {};
  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.

  var defaults = parentDefaults;

  if (isObject(defaults) && isObject(schema["default"])) {
    // For object defaults, only override parent defaults that are defined in
    // schema.default.
    defaults = mergeObjects(defaults, schema["default"]);
  } else if ("default" in schema) {
    // Use schema defaults for this node.
    defaults = schema["default"];
  } else if ("$ref" in schema) {
    // Use referenced schema defaults for this node.
    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);
    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if ("dependencies" in schema) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if (isFixedItems(schema)) {
    defaults = schema.items.map(function (itemSchema, idx) {
      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);
    });
  } else if ("oneOf" in schema) {
    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];
  } else if ("anyOf" in schema) {
    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];
  } // Not defaults defined for this node, fallback to generic typed ones.


  if (typeof defaults === "undefined") {
    defaults = schema["default"];
  }

  switch (getSchemaType(schema)) {
    // We need to recur for object schema inner default values.
    case "object":
      return Object.keys(schema.properties || {}).reduce(function (acc, key) {
        // Compute the defaults for this node, with the parent defaults we might
        // have from a previous run: defaults[key].
        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);

        if (includeUndefinedValues || computedDefault !== undefined) {
          acc[key] = computedDefault;
        }

        return acc;
      }, {});

    case "array":
      // Inject defaults into existing array defaults
      if (Array.isArray(defaults)) {
        defaults = defaults.map(function (item, idx) {
          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);
        });
      } // Deeply inject defaults into already existing form data


      if (Array.isArray(rawFormData)) {
        defaults = rawFormData.map(function (item, idx) {
          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);
        });
      }

      if (schema.minItems) {
        if (!isMultiSelect(schema, rootSchema)) {
          var defaultsLength = defaults ? defaults.length : 0;

          if (schema.minItems > defaultsLength) {
            var defaultEntries = defaults || []; // populate the array with the defaults

            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;
            var fillerEntries = (0, _fill["default"])(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems

            return defaultEntries.concat(fillerEntries);
          }
        } else {
          return defaults ? defaults : [];
        }
      }

  }

  return defaults;
}

function getDefaultFormState(_schema, formData) {
  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (!isObject(_schema)) {
    throw new Error("Invalid schema: " + _schema);
  }

  var schema = retrieveSchema(_schema, rootSchema, formData);
  var defaults = computeDefaults(schema, _schema["default"], rootSchema, formData, includeUndefinedValues);

  if (typeof formData === "undefined") {
    // No form data? Use schema defaults.
    return defaults;
  }

  if (isObject(formData) || Array.isArray(formData)) {
    return mergeDefaultsWithFormData(defaults, formData);
  }

  if (formData === 0 || formData === false || formData === "") {
    return formData;
  }

  return formData || defaults;
}
/**
 * When merging defaults and form data, we want to merge in this specific way:
 * - objects are deeply merged
 * - arrays are merged in such a way that:
 *   - when the array is set in form data, only array entries set in form data
 *     are deeply merged; additional entries from the defaults are ignored
 *   - when the array is not set in form data, the default is copied over
 * - scalars are overwritten/set by form data
 */


function mergeDefaultsWithFormData(defaults, formData) {
  if (Array.isArray(formData)) {
    if (!Array.isArray(defaults)) {
      defaults = [];
    }

    return formData.map(function (value, idx) {
      if (defaults[idx]) {
        return mergeDefaultsWithFormData(defaults[idx], value);
      }

      return value;
    });
  } else if (isObject(formData)) {
    var acc = Object.assign({}, defaults); // Prevent mutation of source object.

    return Object.keys(formData).reduce(function (acc, key) {
      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);
      return acc;
    }, acc);
  } else {
    return formData;
  }
}

function getUiOptions(uiSchema) {
  // get all passed options from ui:widget, ui:options, and ui:<optionName>
  return Object.keys(uiSchema).filter(function (key) {
    return key.indexOf("ui:") === 0;
  }).reduce(function (options, key) {
    var value = uiSchema[key];

    if (key === "ui:widget" && isObject(value)) {
      console.warn("Setting options via ui:widget object is deprecated, use ui:options instead");
      return _objectSpread({}, options, value.options || {}, {
        widget: value.component
      });
    }

    if (key === "ui:options" && isObject(value)) {
      return _objectSpread({}, options, value);
    }

    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));
  }, {});
}

function getDisplayLabel(schema, uiSchema, rootSchema) {
  var uiOptions = getUiOptions(uiSchema);
  var _uiOptions$label = uiOptions.label,
      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;
  var schemaType = getSchemaType(schema);

  if (schemaType === "array") {
    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);
  }

  if (schemaType === "object") {
    displayLabel = false;
  }

  if (schemaType === "boolean" && !uiSchema["ui:widget"]) {
    displayLabel = false;
  }

  if (uiSchema["ui:field"]) {
    displayLabel = false;
  }

  return displayLabel;
}

function isObject(thing) {
  if (typeof File !== "undefined" && thing instanceof File) {
    return false;
  }

  return _typeof(thing) === "object" && thing !== null && !Array.isArray(thing);
}

function mergeObjects(obj1, obj2) {
  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // Recursively merge deeply nested objects.
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeObjects(left, right, concatArrays);
    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
      acc[key] = left.concat(right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}

function asNumber(value) {
  if (value === "") {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  if (/\.$/.test(value)) {
    // "3." can't really be considered a number even if it parses in js. The
    // user is most likely entering a float.
    return value;
  }

  if (/\.0$/.test(value)) {
    // we need to return this as a string here, to allow for input like 3.07
    return value;
  }

  var n = Number(value);
  var valid = typeof n === "number" && !Number.isNaN(n);

  if (/\.\d*0$/.test(value)) {
    // It's a number, that's cool - but we need it as a string so it doesn't screw
    // with the user when entering dollar amounts or other values (such as those with
    // specific precision or number of significant digits)
    return value;
  }

  return valid ? n : value;
}

function orderProperties(properties, order) {
  if (!Array.isArray(order)) {
    return properties;
  }

  var arrayToHash = function arrayToHash(arr) {
    return arr.reduce(function (prev, curr) {
      prev[curr] = true;
      return prev;
    }, {});
  };

  var errorPropList = function errorPropList(arr) {
    return arr.length > 1 ? "properties '".concat(arr.join("', '"), "'") : "property '".concat(arr[0], "'");
  };

  var propertyHash = arrayToHash(properties);
  var orderFiltered = order.filter(function (prop) {
    return prop === "*" || propertyHash[prop];
  });
  var orderHash = arrayToHash(orderFiltered);
  var rest = properties.filter(function (prop) {
    return !orderHash[prop];
  });
  var restIndex = orderFiltered.indexOf("*");

  if (restIndex === -1) {
    if (rest.length) {
      throw new Error("uiSchema order list does not contain ".concat(errorPropList(rest)));
    }

    return orderFiltered;
  }

  if (restIndex !== orderFiltered.lastIndexOf("*")) {
    throw new Error("uiSchema order list contains more than one wildcard item");
  }

  var complete = _toConsumableArray(orderFiltered);

  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));
  return complete;
}
/**
 * This function checks if the given schema matches a single
 * constant value.
 */


function isConstant(schema) {
  return Array.isArray(schema["enum"]) && schema["enum"].length === 1 || schema.hasOwnProperty("const");
}

function toConstant(schema) {
  if (Array.isArray(schema["enum"]) && schema["enum"].length === 1) {
    return schema["enum"][0];
  } else if (schema.hasOwnProperty("const")) {
    return schema["const"];
  } else {
    throw new Error("schema cannot be inferred as a constant");
  }
}

function isSelect(_schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var schema = retrieveSchema(_schema, rootSchema);
  var altSchemas = schema.oneOf || schema.anyOf;

  if (Array.isArray(schema["enum"])) {
    return true;
  } else if (Array.isArray(altSchemas)) {
    return altSchemas.every(function (altSchemas) {
      return isConstant(altSchemas);
    });
  }

  return false;
}

function isMultiSelect(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!schema.uniqueItems || !schema.items) {
    return false;
  }

  return isSelect(schema.items, rootSchema);
}

function isFilesArray(schema, uiSchema) {
  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (uiSchema["ui:widget"] === "files") {
    return true;
  } else if (schema.items) {
    var itemsSchema = retrieveSchema(schema.items, rootSchema);
    return itemsSchema.type === "string" && itemsSchema.format === "data-url";
  }

  return false;
}

function isFixedItems(schema) {
  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {
    return isObject(item);
  });
}

function allowAdditionalItems(schema) {
  if (schema.additionalItems === true) {
    console.warn("additionalItems=true is currently not supported");
  }

  return isObject(schema.additionalItems);
}

function optionsList(schema) {
  if (schema["enum"]) {
    return schema["enum"].map(function (value, i) {
      var label = schema.enumNames && schema.enumNames[i] || String(value);
      return {
        label: label,
        value: value
      };
    });
  } else {
    var altSchemas = schema.oneOf || schema.anyOf;
    return altSchemas.map(function (schema, i) {
      var value = toConstant(schema);
      var label = schema.title || String(value);
      return {
        schema: schema,
        label: label,
        value: value
      };
    });
  }
}

function findSchemaDefinition($ref) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var origRef = $ref;

  if ($ref.startsWith("#")) {
    // Decode URI fragment representation.
    $ref = decodeURIComponent($ref.substring(1));
  } else {
    throw new Error("Could not find a definition for ".concat(origRef, "."));
  }

  var current = _jsonpointer["default"].get(rootSchema, $ref);

  if (current === undefined) {
    throw new Error("Could not find a definition for ".concat(origRef, "."));
  }

  if (current.hasOwnProperty("$ref")) {
    return findSchemaDefinition(current.$ref, rootSchema);
  }

  return current;
} // In the case where we have to implicitly create a schema, it is useful to know what type to use
//  based on the data we are defining


var guessType = function guessType(value) {
  if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "string") {
    return "string";
  } else if (value == null) {
    return "null";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (!isNaN(value)) {
    return "number";
  } else if (_typeof(value) === "object") {
    return "object";
  } // Default to string if we can't figure it out


  return "string";
}; // This function will create new "properties" items for each key in our formData


exports.guessType = guessType;

function stubExistingAdditionalProperties(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Clone the schema so we don't ruin the consumer's original
  schema = _objectSpread({}, schema, {
    properties: _objectSpread({}, schema.properties)
  });
  Object.keys(formData).forEach(function (key) {
    if (schema.properties.hasOwnProperty(key)) {
      // No need to stub, our schema already has the property
      return;
    }

    var additionalProperties;

    if (schema.additionalProperties.hasOwnProperty("$ref")) {
      additionalProperties = retrieveSchema({
        $ref: schema.additionalProperties["$ref"]
      }, rootSchema, formData);
    } else if (schema.additionalProperties.hasOwnProperty("type")) {
      additionalProperties = _objectSpread({}, schema.additionalProperties);
    } else {
      additionalProperties = {
        type: guessType(formData[key])
      };
    } // The type of our new key should match the additionalProperties value;


    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added

    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;
  });
  return schema;
}

function resolveSchema(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (schema.hasOwnProperty("$ref")) {
    return resolveReference(schema, rootSchema, formData);
  } else if (schema.hasOwnProperty("dependencies")) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return retrieveSchema(resolvedSchema, rootSchema, formData);
  } else if (schema.hasOwnProperty("allOf")) {
    return _objectSpread({}, schema, {
      allOf: schema.allOf.map(function (allOfSubschema) {
        return retrieveSchema(allOfSubschema, rootSchema, formData);
      })
    });
  } else {
    // No $ref or dependencies attribute found, returning the original schema.
    return schema;
  }
}

function resolveReference(schema, rootSchema, formData) {
  // Retrieve the referenced schema definition.
  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.

  var $ref = schema.$ref,
      localSchema = _objectWithoutProperties(schema, ["$ref"]); // Update referenced schema definition with local schema properties.


  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);
}

function retrieveSchema(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!isObject(schema)) {
    return {};
  }

  var resolvedSchema = resolveSchema(schema, rootSchema, formData);

  if ("allOf" in schema) {
    try {
      resolvedSchema = (0, _jsonSchemaMergeAllof["default"])(_objectSpread({}, resolvedSchema, {
        allOf: resolvedSchema.allOf
      }));
    } catch (e) {
      console.warn("could not merge subschemas in allOf:\n" + e);

      var _resolvedSchema = resolvedSchema,
          allOf = _resolvedSchema.allOf,
          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, ["allOf"]);

      return resolvedSchemaWithoutAllOf;
    }
  }

  var hasAdditionalProperties = resolvedSchema.hasOwnProperty("additionalProperties") && resolvedSchema.additionalProperties !== false;

  if (hasAdditionalProperties) {
    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function resolveDependencies(schema, rootSchema, formData) {
  // Drop the dependencies from the source schema.
  var _schema$dependencies = schema.dependencies,
      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,
      resolvedSchema = _objectWithoutProperties(schema, ["dependencies"]);

  if ("oneOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];
  } else if ("anyOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];
  }

  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);
}

function processDependencies(dependencies, resolvedSchema, rootSchema, formData) {
  // Process dependencies updating the local schema properties as appropriate.
  for (var dependencyKey in dependencies) {
    // Skip this dependency if its trigger property is not present.
    if (formData[dependencyKey] === undefined) {
      continue;
    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)


    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
      continue;
    }

    var dependencyValue = dependencies[dependencyKey],
        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));

    if (Array.isArray(dependencyValue)) {
      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);
    } else if (isObject(dependencyValue)) {
      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);
    }

    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function withDependentProperties(schema, additionallyRequired) {
  if (!additionallyRequired) {
    return schema;
  }

  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;
  return _objectSpread({}, schema, {
    required: required
  });
}

function withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {
  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),
      oneOf = _retrieveSchema.oneOf,
      dependentSchema = _objectWithoutProperties(_retrieveSchema, ["oneOf"]);

  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.

  if (oneOf === undefined) {
    return schema;
  } else if (!Array.isArray(oneOf)) {
    throw new Error("invalid: it is some ".concat(_typeof(oneOf), " instead of an array"));
  } // Resolve $refs inside oneOf.


  var resolvedOneOf = oneOf.map(function (subschema) {
    return subschema.hasOwnProperty("$ref") ? resolveReference(subschema, rootSchema, formData) : subschema;
  });
  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);
}

function withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {
  var validSubschemas = oneOf.filter(function (subschema) {
    if (!subschema.properties) {
      return false;
    }

    var conditionPropertySchema = subschema.properties[dependencyKey];

    if (conditionPropertySchema) {
      var conditionSchema = {
        type: "object",
        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)
      };

      var _validateFormData = (0, _validate["default"])(formData, conditionSchema),
          errors = _validateFormData.errors;

      return errors.length === 0;
    }
  });

  if (validSubschemas.length !== 1) {
    console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
    return schema;
  }

  var subschema = validSubschemas[0];

  var _subschema$properties = subschema.properties,
      conditionPropertySchema = _subschema$properties[dependencyKey],
      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));

  var dependentSchema = _objectSpread({}, subschema, {
    properties: dependentSubschema
  });

  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));
} // Recursively merge deeply nested schemas.
// The difference between mergeSchemas and mergeObjects
// is that mergeSchemas only concats arrays for
// values under the "required" keyword, and when it does,
// it doesn't include duplicate values.


function mergeSchemas(obj1, obj2) {
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeSchemas(left, right);
    } else if (obj1 && obj2 && (getSchemaType(obj1) === "object" || getSchemaType(obj2) === "object") && key === "required" && Array.isArray(left) && Array.isArray(right)) {
      // Don't include duplicate values when merging
      // "required" fields.
      acc[key] = (0, _union["default"])(left, right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}

function isArguments(object) {
  return Object.prototype.toString.call(object) === "[object Arguments]";
}

function deepEquals(a, b) {
  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  // Partially extracted from node-deeper and adapted to exclude comparison
  // checks for functions.
  // https://github.com/othiym23/node-deeper
  if (a === b) {
    return true;
  } else if (typeof a === "function" || typeof b === "function") {
    // Assume all functions are equivalent
    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255
    return true;
  } else if (_typeof(a) !== "object" || _typeof(b) !== "object") {
    return false;
  } else if (a === null || b === null) {
    return false;
  } else if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  } else if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;
  } else if (isArguments(a) || isArguments(b)) {
    if (!(isArguments(a) && isArguments(b))) {
      return false;
    }

    var slice = Array.prototype.slice;
    return deepEquals(slice.call(a), slice.call(b), ca, cb);
  } else {
    if (a.constructor !== b.constructor) {
      return false;
    }

    var ka = Object.keys(a);
    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there

    if (ka.length === 0 && kb.length === 0) {
      return true;
    }

    if (ka.length !== kb.length) {
      return false;
    }

    var cal = ca.length;

    while (cal--) {
      if (ca[cal] === a) {
        return cb[cal] === b;
      }
    }

    ca.push(a);
    cb.push(b);
    ka.sort();
    kb.sort();

    for (var j = ka.length - 1; j >= 0; j--) {
      if (ka[j] !== kb[j]) {
        return false;
      }
    }

    var _key;

    for (var k = ka.length - 1; k >= 0; k--) {
      _key = ka[k];

      if (!deepEquals(a[_key], b[_key], ca, cb)) {
        return false;
      }
    }

    ca.pop();
    cb.pop();
    return true;
  }
}

function shouldRender(comp, nextProps, nextState) {
  var props = comp.props,
      state = comp.state;
  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);
}

function toIdSchema(schema, id, rootSchema) {
  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "root";
  var idSchema = {
    $id: id || idPrefix
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);
  }

  if ("items" in schema && !schema.items.$ref) {
    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);
  }

  if (schema.type !== "object") {
    return idSchema;
  }

  for (var name in schema.properties || {}) {
    var field = schema.properties[name];
    var fieldId = idSchema.$id + "_" + name;
    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an
    // array item has just been added, but not populated with data yet
    (formData || {})[name], idPrefix);
  }

  return idSchema;
}

function toPathSchema(schema) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;
  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var pathSchema = {
    $name: name.replace(/^\./, "")
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toPathSchema(_schema, name, rootSchema, formData);
  }

  if (schema.hasOwnProperty("additionalProperties")) {
    pathSchema.__rjsf_additionalProperties = true;
  }

  if (schema.hasOwnProperty("items") && Array.isArray(formData)) {
    formData.forEach(function (element, i) {
      pathSchema[i] = toPathSchema(schema.items, "".concat(name, ".").concat(i), rootSchema, element);
    });
  } else if (schema.hasOwnProperty("properties")) {
    for (var property in schema.properties) {
      pathSchema[property] = toPathSchema(schema.properties[property], "".concat(name, ".").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an
      // array item has just been added, but not populated with data yet
      (formData || {})[property]);
    }
  }

  return pathSchema;
}

function parseDateString(dateString) {
  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (!dateString) {
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: includeTime ? -1 : 0,
      minute: includeTime ? -1 : 0,
      second: includeTime ? -1 : 0
    };
  }

  var date = new Date(dateString);

  if (Number.isNaN(date.getTime())) {
    throw new Error("Unable to parse date " + dateString);
  }

  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    // oh you, javascript.
    day: date.getUTCDate(),
    hour: includeTime ? date.getUTCHours() : 0,
    minute: includeTime ? date.getUTCMinutes() : 0,
    second: includeTime ? date.getUTCSeconds() : 0
  };
}

function toDateString(_ref2) {
  var year = _ref2.year,
      month = _ref2.month,
      day = _ref2.day,
      _ref2$hour = _ref2.hour,
      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,
      _ref2$minute = _ref2.minute,
      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,
      _ref2$second = _ref2.second,
      second = _ref2$second === void 0 ? 0 : _ref2$second;
  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);
  var datetime = new Date(utcTime).toJSON();
  return time ? datetime : datetime.slice(0, 10);
}

function utcToLocal(jsonDate) {
  if (!jsonDate) {
    return "";
  } // required format of `"yyyy-MM-ddThh:mm" followed by optional ":ss" or ":ss.SSS"
  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)
  // > should be a _valid local date and time string_ (not GMT)
  // Note - date constructor passed local ISO-8601 does not correctly
  // change time to UTC in node pre-8


  var date = new Date(jsonDate);
  var yyyy = pad(date.getFullYear(), 4);
  var MM = pad(date.getMonth() + 1, 2);
  var dd = pad(date.getDate(), 2);
  var hh = pad(date.getHours(), 2);
  var mm = pad(date.getMinutes(), 2);
  var ss = pad(date.getSeconds(), 2);
  var SSS = pad(date.getMilliseconds(), 3);
  return "".concat(yyyy, "-").concat(MM, "-").concat(dd, "T").concat(hh, ":").concat(mm, ":").concat(ss, ".").concat(SSS);
}

function localToUTC(dateString) {
  if (dateString) {
    return new Date(dateString).toJSON();
  }
}

function pad(num, size) {
  var s = String(num);

  while (s.length < size) {
    s = "0" + s;
  }

  return s;
}

function dataURItoBlob(dataURI) {
  // Split metadata from data
  var splitted = dataURI.split(","); // Split params

  var params = splitted[0].split(";"); // Get mime-type from params

  var type = params[0].replace("data:", ""); // Filter the name property from params

  var properties = params.filter(function (param) {
    return param.split("=")[0] === "name";
  }); // Look for the name and use unknown if no name property.

  var name;

  if (properties.length !== 1) {
    name = "unknown";
  } else {
    // Because we filtered out the other property,
    // we only have the name case here.
    name = properties[0].split("=")[1];
  } // Built the Uint8Array Blob parameter from the base64 string.


  var binary = atob(splitted[1]);
  var array = [];

  for (var _i = 0; _i < binary.length; _i++) {
    array.push(binary.charCodeAt(_i));
  } // Create the blob object


  var blob = new window.Blob([new Uint8Array(array)], {
    type: type
  });
  return {
    blob: blob,
    name: name
  };
}

function rangeSpec(schema) {
  var spec = {};

  if (schema.multipleOf) {
    spec.step = schema.multipleOf;
  }

  if (schema.minimum || schema.minimum === 0) {
    spec.min = schema.minimum;
  }

  if (schema.maximum || schema.maximum === 0) {
    spec.max = schema.maximum;
  }

  return spec;
}

function getMatchingOption(formData, options, rootSchema) {
  for (var _i2 = 0; _i2 < options.length; _i2++) {
    var option = options[_i2]; // If the schema describes an object then we need to add slightly more
    // strict matching to the schema, because unless the schema uses the
    // "requires" keyword, an object will match the schema as long as it
    // doesn't have matching keys with a conflicting type. To do this we use an
    // "anyOf" with an array of requires. This augmentation expresses that the
    // schema should match if any of the keys in the schema are present on the
    // object and pass validation.

    if (option.properties) {
      // Create an "anyOf" schema that requires at least one of the keys in the
      // "properties" object
      var requiresAnyOf = {
        anyOf: Object.keys(option.properties).map(function (key) {
          return {
            required: [key]
          };
        })
      };
      var augmentedSchema = void 0; // If the "anyOf" keyword already exists, wrap the augmentation in an "allOf"

      if (option.anyOf) {
        // Create a shallow clone of the option
        var shallowClone = _extends({}, option);

        if (!shallowClone.allOf) {
          shallowClone.allOf = [];
        } else {
          // If "allOf" already exists, shallow clone the array
          shallowClone.allOf = shallowClone.allOf.slice();
        }

        shallowClone.allOf.push(requiresAnyOf);
        augmentedSchema = shallowClone;
      } else {
        augmentedSchema = Object.assign({}, option, requiresAnyOf);
      } // Remove the "required" field as it's likely that not all fields have
      // been filled in yet, which will mean that the schema is not valid


      delete augmentedSchema.required;

      if ((0, _validate.isValid)(augmentedSchema, formData, rootSchema)) {
        return _i2;
      }
    } else if ((0, _validate.isValid)(option, formData, rootSchema)) {
      return _i2;
    }
  }

  return 0;
} // Check to see if a schema specifies that a value must be true


function schemaRequiresTrueValue(schema) {
  // Check if const is a truthy value
  if (schema["const"]) {
    return true;
  } // Check if an enum has a single value of true


  if (schema["enum"] && schema["enum"].length === 1 && schema["enum"][0] === true) {
    return true;
  } // If anyOf has a single value, evaluate the subschema


  if (schema.anyOf && schema.anyOf.length === 1) {
    return schemaRequiresTrueValue(schema.anyOf[0]);
  } // If oneOf has a single value, evaluate the subschema


  if (schema.oneOf && schema.oneOf.length === 1) {
    return schemaRequiresTrueValue(schema.oneOf[0]);
  } // Evaluate each subschema in allOf, to see if one of them requires a true
  // value


  if (schema.allOf) {
    return schema.allOf.some(schemaRequiresTrueValue);
  }

  return false;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJBRERJVElPTkFMX1BST1BFUlRZX0ZMQUciLCJ3aWRnZXRNYXAiLCJjaGVja2JveCIsInJhZGlvIiwic2VsZWN0IiwiaGlkZGVuIiwic3RyaW5nIiwidGV4dCIsInBhc3N3b3JkIiwiZW1haWwiLCJob3N0bmFtZSIsImlwdjQiLCJpcHY2IiwidXJpIiwidGV4dGFyZWEiLCJkYXRlIiwiZGF0ZXRpbWUiLCJjb2xvciIsImZpbGUiLCJudW1iZXIiLCJ1cGRvd24iLCJyYW5nZSIsImludGVnZXIiLCJhcnJheSIsImNoZWNrYm94ZXMiLCJmaWxlcyIsImNhbkV4cGFuZCIsInNjaGVtYSIsInVpU2NoZW1hIiwiZm9ybURhdGEiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImdldFVpT3B0aW9ucyIsImV4cGFuZGFibGUiLCJtYXhQcm9wZXJ0aWVzIiwidW5kZWZpbmVkIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImdldERlZmF1bHRSZWdpc3RyeSIsImZpZWxkcyIsIndpZGdldHMiLCJkZWZpbml0aW9ucyIsInJvb3RTY2hlbWEiLCJmb3JtQ29udGV4dCIsImdldFNjaGVtYVR5cGUiLCJ0eXBlIiwiZ3Vlc3NUeXBlIiwicHJvcGVydGllcyIsIkFycmF5IiwiaW5jbHVkZXMiLCJmaW5kIiwiZ2V0V2lkZ2V0Iiwid2lkZ2V0IiwicmVnaXN0ZXJlZFdpZGdldHMiLCJtZXJnZU9wdGlvbnMiLCJXaWRnZXQiLCJNZXJnZWRXaWRnZXQiLCJkZWZhdWx0T3B0aW9ucyIsImRlZmF1bHRQcm9wcyIsIm9wdGlvbnMiLCJwcm9wcyIsIlJlYWN0SXMiLCJpc0ZvcndhcmRSZWYiLCJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJpc01lbW8iLCJFcnJvciIsImhhc093blByb3BlcnR5IiwicmVnaXN0ZXJlZFdpZGdldCIsImhhc1dpZGdldCIsImUiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsImNvbXB1dGVEZWZhdWx0cyIsIl9zY2hlbWEiLCJwYXJlbnREZWZhdWx0cyIsInJhd0Zvcm1EYXRhIiwiaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyIsImlzT2JqZWN0IiwiZGVmYXVsdHMiLCJtZXJnZU9iamVjdHMiLCJyZWZTY2hlbWEiLCJmaW5kU2NoZW1hRGVmaW5pdGlvbiIsIiRyZWYiLCJyZXNvbHZlZFNjaGVtYSIsInJlc29sdmVEZXBlbmRlbmNpZXMiLCJpc0ZpeGVkSXRlbXMiLCJpdGVtcyIsIm1hcCIsIml0ZW1TY2hlbWEiLCJpZHgiLCJpc0FycmF5Iiwib25lT2YiLCJnZXRNYXRjaGluZ09wdGlvbiIsImFueU9mIiwicmVkdWNlIiwiYWNjIiwia2V5IiwiY29tcHV0ZWREZWZhdWx0IiwiaXRlbSIsImFkZGl0aW9uYWxJdGVtcyIsIm1pbkl0ZW1zIiwiaXNNdWx0aVNlbGVjdCIsImRlZmF1bHRzTGVuZ3RoIiwiZGVmYXVsdEVudHJpZXMiLCJmaWxsZXJTY2hlbWEiLCJmaWxsZXJFbnRyaWVzIiwiY29uY2F0IiwiZ2V0RGVmYXVsdEZvcm1TdGF0ZSIsInJldHJpZXZlU2NoZW1hIiwibWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YSIsInZhbHVlIiwiYXNzaWduIiwiZmlsdGVyIiwiaW5kZXhPZiIsImNvbnNvbGUiLCJ3YXJuIiwiY29tcG9uZW50Iiwic3Vic3RyaW5nIiwiZ2V0RGlzcGxheUxhYmVsIiwidWlPcHRpb25zIiwibGFiZWwiLCJkaXNwbGF5TGFiZWwiLCJzY2hlbWFUeXBlIiwiaXNGaWxlc0FycmF5IiwidGhpbmciLCJGaWxlIiwib2JqMSIsIm9iajIiLCJjb25jYXRBcnJheXMiLCJsZWZ0IiwicmlnaHQiLCJhc051bWJlciIsInRlc3QiLCJuIiwiTnVtYmVyIiwidmFsaWQiLCJpc05hTiIsIm9yZGVyUHJvcGVydGllcyIsIm9yZGVyIiwiYXJyYXlUb0hhc2giLCJhcnIiLCJwcmV2IiwiY3VyciIsImVycm9yUHJvcExpc3QiLCJqb2luIiwicHJvcGVydHlIYXNoIiwib3JkZXJGaWx0ZXJlZCIsInByb3AiLCJvcmRlckhhc2giLCJyZXN0IiwicmVzdEluZGV4IiwibGFzdEluZGV4T2YiLCJjb21wbGV0ZSIsInNwbGljZSIsImlzQ29uc3RhbnQiLCJ0b0NvbnN0YW50IiwiaXNTZWxlY3QiLCJhbHRTY2hlbWFzIiwiZXZlcnkiLCJ1bmlxdWVJdGVtcyIsIml0ZW1zU2NoZW1hIiwiZm9ybWF0IiwiYWxsb3dBZGRpdGlvbmFsSXRlbXMiLCJvcHRpb25zTGlzdCIsImkiLCJlbnVtTmFtZXMiLCJTdHJpbmciLCJ0aXRsZSIsIm9yaWdSZWYiLCJkZWNvZGVVUklDb21wb25lbnQiLCJjdXJyZW50IiwianNvbnBvaW50ZXIiLCJnZXQiLCJzdHViRXhpc3RpbmdBZGRpdGlvbmFsUHJvcGVydGllcyIsImZvckVhY2giLCJyZXNvbHZlU2NoZW1hIiwicmVzb2x2ZVJlZmVyZW5jZSIsImFsbE9mIiwiYWxsT2ZTdWJzY2hlbWEiLCIkcmVmU2NoZW1hIiwibG9jYWxTY2hlbWEiLCJyZXNvbHZlZFNjaGVtYVdpdGhvdXRBbGxPZiIsImhhc0FkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiZGVwZW5kZW5jaWVzIiwicHJvY2Vzc0RlcGVuZGVuY2llcyIsImRlcGVuZGVuY3lLZXkiLCJkZXBlbmRlbmN5VmFsdWUiLCJyZW1haW5pbmdEZXBlbmRlbmNpZXMiLCJ3aXRoRGVwZW5kZW50UHJvcGVydGllcyIsIndpdGhEZXBlbmRlbnRTY2hlbWEiLCJhZGRpdGlvbmFsbHlSZXF1aXJlZCIsInJlcXVpcmVkIiwiZnJvbSIsIlNldCIsImRlcGVuZGVudFNjaGVtYSIsIm1lcmdlU2NoZW1hcyIsInJlc29sdmVkT25lT2YiLCJzdWJzY2hlbWEiLCJ3aXRoRXhhY3RseU9uZVN1YnNjaGVtYSIsInZhbGlkU3Vic2NoZW1hcyIsImNvbmRpdGlvblByb3BlcnR5U2NoZW1hIiwiY29uZGl0aW9uU2NoZW1hIiwiZXJyb3JzIiwiZGVwZW5kZW50U3Vic2NoZW1hIiwiaXNBcmd1bWVudHMiLCJvYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJkZWVwRXF1YWxzIiwiYSIsImIiLCJjYSIsImNiIiwiRGF0ZSIsImdldFRpbWUiLCJSZWdFeHAiLCJzb3VyY2UiLCJnbG9iYWwiLCJtdWx0aWxpbmUiLCJsYXN0SW5kZXgiLCJpZ25vcmVDYXNlIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsImthIiwia2IiLCJjYWwiLCJwdXNoIiwic29ydCIsImoiLCJrIiwicG9wIiwic2hvdWxkUmVuZGVyIiwiY29tcCIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsInN0YXRlIiwidG9JZFNjaGVtYSIsImlkIiwiaWRQcmVmaXgiLCJpZFNjaGVtYSIsIiRpZCIsIm5hbWUiLCJmaWVsZCIsImZpZWxkSWQiLCJ0b1BhdGhTY2hlbWEiLCJwYXRoU2NoZW1hIiwiJG5hbWUiLCJyZXBsYWNlIiwiX19yanNmX2FkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiZWxlbWVudCIsInByb3BlcnR5IiwicGFyc2VEYXRlU3RyaW5nIiwiZGF0ZVN0cmluZyIsImluY2x1ZGVUaW1lIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInRvRGF0ZVN0cmluZyIsInRpbWUiLCJ1dGNUaW1lIiwiVVRDIiwidG9KU09OIiwidXRjVG9Mb2NhbCIsImpzb25EYXRlIiwieXl5eSIsInBhZCIsImdldEZ1bGxZZWFyIiwiTU0iLCJnZXRNb250aCIsImRkIiwiZ2V0RGF0ZSIsImhoIiwiZ2V0SG91cnMiLCJtbSIsImdldE1pbnV0ZXMiLCJzcyIsImdldFNlY29uZHMiLCJTU1MiLCJnZXRNaWxsaXNlY29uZHMiLCJsb2NhbFRvVVRDIiwibnVtIiwic2l6ZSIsInMiLCJkYXRhVVJJdG9CbG9iIiwiZGF0YVVSSSIsInNwbGl0dGVkIiwic3BsaXQiLCJwYXJhbXMiLCJwYXJhbSIsImJpbmFyeSIsImF0b2IiLCJjaGFyQ29kZUF0IiwiYmxvYiIsIndpbmRvdyIsIkJsb2IiLCJVaW50OEFycmF5IiwicmFuZ2VTcGVjIiwic3BlYyIsIm11bHRpcGxlT2YiLCJzdGVwIiwibWluaW11bSIsIm1pbiIsIm1heGltdW0iLCJtYXgiLCJvcHRpb24iLCJyZXF1aXJlc0FueU9mIiwiYXVnbWVudGVkU2NoZW1hIiwic2hhbGxvd0Nsb25lIiwic2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUiLCJzb21lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVPLElBQU1BLHdCQUF3QixHQUFHLHVCQUFqQzs7QUFFUCxJQUFNQyxTQUFTLEdBQUc7QUFDaEIsYUFBUztBQUNQQyxJQUFBQSxRQUFRLEVBQUUsZ0JBREg7QUFFUEMsSUFBQUEsS0FBSyxFQUFFLGFBRkE7QUFHUEMsSUFBQUEsTUFBTSxFQUFFLGNBSEQ7QUFJUEMsSUFBQUEsTUFBTSxFQUFFO0FBSkQsR0FETztBQU9oQkMsRUFBQUEsTUFBTSxFQUFFO0FBQ05DLElBQUFBLElBQUksRUFBRSxZQURBO0FBRU5DLElBQUFBLFFBQVEsRUFBRSxnQkFGSjtBQUdOQyxJQUFBQSxLQUFLLEVBQUUsYUFIRDtBQUlOQyxJQUFBQSxRQUFRLEVBQUUsWUFKSjtBQUtOQyxJQUFBQSxJQUFJLEVBQUUsWUFMQTtBQU1OQyxJQUFBQSxJQUFJLEVBQUUsWUFOQTtBQU9OQyxJQUFBQSxHQUFHLEVBQUUsV0FQQztBQVFOLGdCQUFZLFlBUk47QUFTTlYsSUFBQUEsS0FBSyxFQUFFLGFBVEQ7QUFVTkMsSUFBQUEsTUFBTSxFQUFFLGNBVkY7QUFXTlUsSUFBQUEsUUFBUSxFQUFFLGdCQVhKO0FBWU5ULElBQUFBLE1BQU0sRUFBRSxjQVpGO0FBYU5VLElBQUFBLElBQUksRUFBRSxZQWJBO0FBY05DLElBQUFBLFFBQVEsRUFB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cG9ydCAqIGFzIFJlYWN0SXMgZnJvbSBcInJlYWN0LWlzXCI7XG5pbXBvcnQgbWVyZ2VBbGxPZiBmcm9tIFwianNvbi1zY2hlbWEtbWVyZ2UtYWxsb2ZcIjtcbmltcG9ydCBmaWxsIGZyb20gXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvYXJyYXkvZmlsbFwiO1xuaW1wb3J0IHVuaW9uIGZyb20gXCJsb2Rhc2gvdW5pb25cIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbnBvaW50ZXJcIjtcbmltcG9ydCBmaWVsZHMgZnJvbSBcIi4vY29tcG9uZW50cy9maWVsZHNcIjtcbmltcG9ydCB3aWRnZXRzIGZyb20gXCIuL2NvbXBvbmVudHMvd2lkZ2V0c1wiO1xuaW1wb3J0IHZhbGlkYXRlRm9ybURhdGEsIHsgaXNWYWxpZCB9IGZyb20gXCIuL3ZhbGlkYXRlXCI7XG5cbmV4cG9ydCBjb25zdCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcgPSBcIl9fYWRkaXRpb25hbF9wcm9wZXJ0eVwiO1xuXG5jb25zdCB3aWRnZXRNYXAgPSB7XG4gIGJvb2xlYW46IHtcbiAgICBjaGVja2JveDogXCJDaGVja2JveFdpZGdldFwiLFxuICAgIHJhZGlvOiBcIlJhZGlvV2lkZ2V0XCIsXG4gICAgc2VsZWN0OiBcIlNlbGVjdFdpZGdldFwiLFxuICAgIGhpZGRlbjogXCJIaWRkZW5XaWRnZXRcIixcbiAgfSxcbiAgc3RyaW5nOiB7XG4gICAgdGV4dDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgcGFzc3dvcmQ6IFwiUGFzc3dvcmRXaWRnZXRcIixcbiAgICBlbWFpbDogXCJFbWFpbFdpZGdldFwiLFxuICAgIGhvc3RuYW1lOiBcIlRleHRXaWRnZXRcIixcbiAgICBpcHY0OiBcIlRleHRXaWRnZXRcIixcbiAgICBpcHY2OiBcIlRleHRXaWRnZXRcIixcbiAgICB1cmk6IFwiVVJMV2lkZ2V0XCIsXG4gICAgXCJkYXRhLXVybFwiOiBcIkZpbGVXaWRnZXRcIixcbiAgICByYWRpbzogXCJSYWRpb1dpZGdldFwiLFxuICAgIHNlbGVjdDogXCJTZWxlY3RXaWRnZXRcIixcbiAgICB0ZXh0YXJlYTogXCJUZXh0YXJlYVdpZGdldFwiLFxuICAgIGhpZGRlbjogXCJIaWRkZW5XaWRnZXRcIixcbiAgICBkYXRlOiBcIkRhdGVXaWRnZXRcIixcbiAgICBkYXRldGltZTogXCJEYXRlVGltZVdpZGdldFwiLFxuICAgIFwiZGF0ZS10aW1lXCI6IFwiRGF0ZVRpbWVXaWRnZXRcIixcbiAgICBcImFsdC1kYXRlXCI6IFwiQWx0RGF0ZVdpZGdldFwiLFxuICAgIFwiYWx0LWRhdGV0aW1lXCI6IFwiQWx0RGF0ZVRpbWVXaWRnZXRcIixcbiAgICBjb2xvcjogXCJDb2xvcldpZGdldFwiLFxuICAgIGZpbGU6IFwiRmlsZVdpZGdldFwiLFxuICB9LFxuICBudW1iZXI6IHtcbiAgICB0ZXh0OiBcIlRleHRXaWRnZXRcIixcbiAgICBzZWxlY3Q6IFwiU2VsZWN0V2lkZ2V0XCIsXG4gICAgdXBkb3duOiBcIlVwRG93bldpZGdldFwiLFxuICAgIHJhbmdlOiBcIlJhbmdlV2lkZ2V0XCIsXG4gICAgcmFkaW86IFwiUmFkaW9XaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gIH0sXG4gIGludGVnZXI6IHtcbiAgICB0ZXh0OiBcIlRleHRXaWRnZXRcIixcbiAgICBzZWxlY3Q6IFwiU2VsZWN0V2lkZ2V0XCIsXG4gICAgdXBkb3duOiBcIlVwRG93bldpZGdldFwiLFxuICAgIHJhbmdlOiBcIlJhbmdlV2lkZ2V0XCIsXG4gICAgcmFkaW86IFwiUmFkaW9XaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gIH0sXG4gIGFycmF5OiB7XG4gICAgc2VsZWN0OiBcIlNlbGVjdFdpZGdldFwiLFxuICAgIGNoZWNrYm94ZXM6IFwiQ2hlY2tib3hlc1dpZGdldFwiLFxuICAgIGZpbGVzOiBcIkZpbGVXaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2FuRXhwYW5kKHNjaGVtYSwgdWlTY2hlbWEsIGZvcm1EYXRhKSB7XG4gIGlmICghc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgZXhwYW5kYWJsZSB9ID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgaWYgKGV4cGFuZGFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGV4cGFuZGFibGU7XG4gIH1cbiAgLy8gaWYgdWk6b3B0aW9ucy5leHBhbmRhYmxlIHdhcyBub3QgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UsIHdlIGNhbiBhZGRcbiAgLy8gYW5vdGhlciBwcm9wZXJ0eSBpZiB3ZSBoYXZlIG5vdCBleGNlZWRlZCBtYXhQcm9wZXJ0aWVzIHlldFxuICBpZiAoc2NoZW1hLm1heFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhmb3JtRGF0YSkubGVuZ3RoIDwgc2NoZW1hLm1heFByb3BlcnRpZXM7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UmVnaXN0cnkoKSB7XG4gIHJldHVybiB7XG4gICAgZmllbGRzLFxuICAgIHdpZGdldHMsXG4gICAgZGVmaW5pdGlvbnM6IHt9LFxuICAgIHJvb3RTY2hlbWE6IHt9LFxuICAgIGZvcm1Db250ZXh0OiB7fSxcbiAgfTtcbn1cblxuLyogR2V0cyB0aGUgdHlwZSBvZiBhIGdpdmVuIHNjaGVtYS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlKHNjaGVtYSkge1xuICBsZXQgeyB0eXBlIH0gPSBzY2hlbWE7XG5cbiAgaWYgKCF0eXBlICYmIHNjaGVtYS5jb25zdCkge1xuICAgIHJldHVybiBndWVzc1R5cGUoc2NoZW1hLmNvbnN0KTtcbiAgfVxuXG4gIGlmICghdHlwZSAmJiBzY2hlbWEuZW51bSkge1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgaWYgKCF0eXBlICYmIChzY2hlbWEucHJvcGVydGllcyB8fCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpKSB7XG4gICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gIH1cblxuICBpZiAodHlwZSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGUubGVuZ3RoID09PSAyICYmIHR5cGUuaW5jbHVkZXMoXCJudWxsXCIpKSB7XG4gICAgcmV0dXJuIHR5cGUuZmluZCh0eXBlID0+IHR5cGUgIT09IFwibnVsbFwiKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2lkZ2V0KHNjaGVtYSwgd2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyA9IHt9KSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRTY2hlbWFUeXBlKHNjaGVtYSk7XG5cbiAgZnVuY3Rpb24gbWVyZ2VPcHRpb25zKFdpZGdldCkge1xuICAgIC8vIGNhY2hlIHJldHVybiB2YWx1ZSBhcyBwcm9wZXJ0eSBvZiB3aWRnZXQgZm9yIHByb3BlciByZWFjdCByZWNvbmNpbGlhdGlvblxuICAgIGlmICghV2lkZ2V0Lk1lcmdlZFdpZGdldCkge1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPVxuICAgICAgICAoV2lkZ2V0LmRlZmF1bHRQcm9wcyAmJiBXaWRnZXQuZGVmYXVsdFByb3BzLm9wdGlvbnMpIHx8IHt9O1xuICAgICAgV2lkZ2V0Lk1lcmdlZFdpZGdldCA9ICh7IG9wdGlvbnMgPSB7fSwgLi4ucHJvcHMgfSkgPT4gKFxuICAgICAgICA8V2lkZ2V0IG9wdGlvbnM9e3sgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfX0gey4uLnByb3BzfSAvPlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFdpZGdldC5NZXJnZWRXaWRnZXQ7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIHdpZGdldCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgUmVhY3RJcy5pc0ZvcndhcmRSZWYoUmVhY3QuY3JlYXRlRWxlbWVudCh3aWRnZXQpKSB8fFxuICAgIFJlYWN0SXMuaXNNZW1vKHdpZGdldClcbiAgKSB7XG4gICAgcmV0dXJuIG1lcmdlT3B0aW9ucyh3aWRnZXQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aWRnZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHdpZGdldCBkZWZpbml0aW9uOiAke3R5cGVvZiB3aWRnZXR9YCk7XG4gIH1cblxuICBpZiAocmVnaXN0ZXJlZFdpZGdldHMuaGFzT3duUHJvcGVydHkod2lkZ2V0KSkge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRXaWRnZXQgPSByZWdpc3RlcmVkV2lkZ2V0c1t3aWRnZXRdO1xuICAgIHJldHVybiBnZXRXaWRnZXQoc2NoZW1hLCByZWdpc3RlcmVkV2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyk7XG4gIH1cblxuICBpZiAoIXdpZGdldE1hcC5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gd2lkZ2V0IGZvciB0eXBlIFwiJHt0eXBlfVwiYCk7XG4gIH1cblxuICBpZiAod2lkZ2V0TWFwW3R5cGVdLmhhc093blByb3BlcnR5KHdpZGdldCkpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkV2lkZ2V0ID0gcmVnaXN0ZXJlZFdpZGdldHNbd2lkZ2V0TWFwW3R5cGVdW3dpZGdldF1dO1xuICAgIHJldHVybiBnZXRXaWRnZXQoc2NoZW1hLCByZWdpc3RlcmVkV2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYE5vIHdpZGdldCBcIiR7d2lkZ2V0fVwiIGZvciB0eXBlIFwiJHt0eXBlfVwiYCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHJlZ2lzdGVyZWRXaWRnZXRzID0ge30pIHtcbiAgdHJ5IHtcbiAgICBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHJlZ2lzdGVyZWRXaWRnZXRzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChcbiAgICAgIGUubWVzc2FnZSAmJlxuICAgICAgKGUubWVzc2FnZS5zdGFydHNXaXRoKFwiTm8gd2lkZ2V0XCIpIHx8XG4gICAgICAgIGUubWVzc2FnZS5zdGFydHNXaXRoKFwiVW5zdXBwb3J0ZWQgd2lkZ2V0XCIpKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0cyhcbiAgX3NjaGVtYSxcbiAgcGFyZW50RGVmYXVsdHMsXG4gIHJvb3RTY2hlbWEsXG4gIHJhd0Zvcm1EYXRhID0ge30sXG4gIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMgPSBmYWxzZVxuKSB7XG4gIGxldCBzY2hlbWEgPSBpc09iamVjdChfc2NoZW1hKSA/IF9zY2hlbWEgOiB7fTtcbiAgY29uc3QgZm9ybURhdGEgPSBpc09iamVjdChyYXdGb3JtRGF0YSkgPyByYXdGb3JtRGF0YSA6IHt9O1xuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0cyByZWN1cnNpdmVseTogZ2l2ZSBoaWdoZXN0IHByaW9yaXR5IHRvIGRlZXBlc3Qgbm9kZXMuXG4gIGxldCBkZWZhdWx0cyA9IHBhcmVudERlZmF1bHRzO1xuICBpZiAoaXNPYmplY3QoZGVmYXVsdHMpICYmIGlzT2JqZWN0KHNjaGVtYS5kZWZhdWx0KSkge1xuICAgIC8vIEZvciBvYmplY3QgZGVmYXVsdHMsIG9ubHkgb3ZlcnJpZGUgcGFyZW50IGRlZmF1bHRzIHRoYXQgYXJlIGRlZmluZWQgaW5cbiAgICAvLyBzY2hlbWEuZGVmYXVsdC5cbiAgICBkZWZhdWx0cyA9IG1lcmdlT2JqZWN0cyhkZWZhdWx0cywgc2NoZW1hLmRlZmF1bHQpO1xuICB9IGVsc2UgaWYgKFwiZGVmYXVsdFwiIGluIHNjaGVtYSkge1xuICAgIC8vIFVzZSBzY2hlbWEgZGVmYXVsdHMgZm9yIHRoaXMgbm9kZS5cbiAgICBkZWZhdWx0cyA9IHNjaGVtYS5kZWZhdWx0O1xuICB9IGVsc2UgaWYgKFwiJHJlZlwiIGluIHNjaGVtYSkge1xuICAgIC8vIFVzZSByZWZlcmVuY2VkIHNjaGVtYSBkZWZhdWx0cyBmb3IgdGhpcyBub2RlLlxuICAgIGNvbnN0IHJlZlNjaGVtYSA9IGZpbmRTY2hlbWFEZWZpbml0aW9uKHNjaGVtYS4kcmVmLCByb290U2NoZW1hKTtcbiAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRzKFxuICAgICAgcmVmU2NoZW1hLFxuICAgICAgZGVmYXVsdHMsXG4gICAgICByb290U2NoZW1hLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzXG4gICAgKTtcbiAgfSBlbHNlIGlmIChcImRlcGVuZGVuY2llc1wiIGluIHNjaGVtYSkge1xuICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gcmVzb2x2ZURlcGVuZGVuY2llcyhzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRzKFxuICAgICAgcmVzb2x2ZWRTY2hlbWEsXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzRml4ZWRJdGVtcyhzY2hlbWEpKSB7XG4gICAgZGVmYXVsdHMgPSBzY2hlbWEuaXRlbXMubWFwKChpdGVtU2NoZW1hLCBpZHgpID0+XG4gICAgICBjb21wdXRlRGVmYXVsdHMoXG4gICAgICAgIGl0ZW1TY2hlbWEsXG4gICAgICAgIEFycmF5LmlzQXJyYXkocGFyZW50RGVmYXVsdHMpID8gcGFyZW50RGVmYXVsdHNbaWR4XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNcbiAgICAgIClcbiAgICApO1xuICB9IGVsc2UgaWYgKFwib25lT2ZcIiBpbiBzY2hlbWEpIHtcbiAgICBzY2hlbWEgPVxuICAgICAgc2NoZW1hLm9uZU9mW2dldE1hdGNoaW5nT3B0aW9uKHVuZGVmaW5lZCwgc2NoZW1hLm9uZU9mLCByb290U2NoZW1hKV07XG4gIH0gZWxzZSBpZiAoXCJhbnlPZlwiIGluIHNjaGVtYSkge1xuICAgIHNjaGVtYSA9XG4gICAgICBzY2hlbWEuYW55T2ZbZ2V0TWF0Y2hpbmdPcHRpb24odW5kZWZpbmVkLCBzY2hlbWEuYW55T2YsIHJvb3RTY2hlbWEpXTtcbiAgfVxuXG4gIC8vIE5vdCBkZWZhdWx0cyBkZWZpbmVkIGZvciB0aGlzIG5vZGUsIGZhbGxiYWNrIHRvIGdlbmVyaWMgdHlwZWQgb25lcy5cbiAgaWYgKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGRlZmF1bHRzID0gc2NoZW1hLmRlZmF1bHQ7XG4gIH1cblxuICBzd2l0Y2ggKGdldFNjaGVtYVR5cGUoc2NoZW1hKSkge1xuICAgIC8vIFdlIG5lZWQgdG8gcmVjdXIgZm9yIG9iamVjdCBzY2hlbWEgaW5uZXIgZGVmYXVsdCB2YWx1ZXMuXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9KS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGRlZmF1bHRzIGZvciB0aGlzIG5vZGUsIHdpdGggdGhlIHBhcmVudCBkZWZhdWx0cyB3ZSBtaWdodFxuICAgICAgICAvLyBoYXZlIGZyb20gYSBwcmV2aW91cyBydW46IGRlZmF1bHRzW2tleV0uXG4gICAgICAgIGxldCBjb21wdXRlZERlZmF1bHQgPSBjb21wdXRlRGVmYXVsdHMoXG4gICAgICAgICAgc2NoZW1hLnByb3BlcnRpZXNba2V5XSxcbiAgICAgICAgICAoZGVmYXVsdHMgfHwge30pW2tleV0sXG4gICAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgICAoZm9ybURhdGEgfHwge30pW2tleV0sXG4gICAgICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc1xuICAgICAgICApO1xuICAgICAgICBpZiAoaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyB8fCBjb21wdXRlZERlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFjY1trZXldID0gY29tcHV0ZWREZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG5cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIC8vIEluamVjdCBkZWZhdWx0cyBpbnRvIGV4aXN0aW5nIGFycmF5IGRlZmF1bHRzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcbiAgICAgICAgZGVmYXVsdHMgPSBkZWZhdWx0cy5tYXAoKGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21wdXRlRGVmYXVsdHMoXG4gICAgICAgICAgICBzY2hlbWEuaXRlbXNbaWR4XSB8fCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zIHx8IHt9LFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIHJvb3RTY2hlbWFcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVlcGx5IGluamVjdCBkZWZhdWx0cyBpbnRvIGFscmVhZHkgZXhpc3RpbmcgZm9ybSBkYXRhXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdGb3JtRGF0YSkpIHtcbiAgICAgICAgZGVmYXVsdHMgPSByYXdGb3JtRGF0YS5tYXAoKGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21wdXRlRGVmYXVsdHMoXG4gICAgICAgICAgICBzY2hlbWEuaXRlbXMsXG4gICAgICAgICAgICAoZGVmYXVsdHMgfHwge30pW2lkeF0sXG4gICAgICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNjaGVtYS5taW5JdGVtcykge1xuICAgICAgICBpZiAoIWlzTXVsdGlTZWxlY3Qoc2NoZW1hLCByb290U2NoZW1hKSkge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRzTGVuZ3RoID0gZGVmYXVsdHMgPyBkZWZhdWx0cy5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmIChzY2hlbWEubWluSXRlbXMgPiBkZWZhdWx0c0xlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVudHJpZXMgPSBkZWZhdWx0cyB8fCBbXTtcbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIHRoZSBhcnJheSB3aXRoIHRoZSBkZWZhdWx0c1xuICAgICAgICAgICAgY29uc3QgZmlsbGVyU2NoZW1hID0gQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpXG4gICAgICAgICAgICAgID8gc2NoZW1hLmFkZGl0aW9uYWxJdGVtc1xuICAgICAgICAgICAgICA6IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGZpbGxlckVudHJpZXMgPSBmaWxsKFxuICAgICAgICAgICAgICBuZXcgQXJyYXkoc2NoZW1hLm1pbkl0ZW1zIC0gZGVmYXVsdHNMZW5ndGgpLFxuICAgICAgICAgICAgICBjb21wdXRlRGVmYXVsdHMoZmlsbGVyU2NoZW1hLCBmaWxsZXJTY2hlbWEuZGVmYXVsdHMsIHJvb3RTY2hlbWEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gdGhlbiBmaWxsIHVwIHRoZSByZXN0IHdpdGggZWl0aGVyIHRoZSBpdGVtIGRlZmF1bHQgb3IgZW1wdHksIHVwIHRvIG1pbkl0ZW1zXG5cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RW50cmllcy5jb25jYXQoZmlsbGVyRW50cmllcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0cyA/IGRlZmF1bHRzIDogW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Rm9ybVN0YXRlKFxuICBfc2NoZW1hLFxuICBmb3JtRGF0YSxcbiAgcm9vdFNjaGVtYSA9IHt9LFxuICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzID0gZmFsc2Vcbikge1xuICBpZiAoIWlzT2JqZWN0KF9zY2hlbWEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzY2hlbWE6IFwiICsgX3NjaGVtYSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gcmV0cmlldmVTY2hlbWEoX3NjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICBjb25zdCBkZWZhdWx0cyA9IGNvbXB1dGVEZWZhdWx0cyhcbiAgICBzY2hlbWEsXG4gICAgX3NjaGVtYS5kZWZhdWx0LFxuICAgIHJvb3RTY2hlbWEsXG4gICAgZm9ybURhdGEsXG4gICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc1xuICApO1xuICBpZiAodHlwZW9mIGZvcm1EYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gTm8gZm9ybSBkYXRhPyBVc2Ugc2NoZW1hIGRlZmF1bHRzLlxuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuICBpZiAoaXNPYmplY3QoZm9ybURhdGEpIHx8IEFycmF5LmlzQXJyYXkoZm9ybURhdGEpKSB7XG4gICAgcmV0dXJuIG1lcmdlRGVmYXVsdHNXaXRoRm9ybURhdGEoZGVmYXVsdHMsIGZvcm1EYXRhKTtcbiAgfVxuICBpZiAoZm9ybURhdGEgPT09IDAgfHwgZm9ybURhdGEgPT09IGZhbHNlIHx8IGZvcm1EYXRhID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZvcm1EYXRhO1xuICB9XG4gIHJldHVybiBmb3JtRGF0YSB8fCBkZWZhdWx0cztcbn1cblxuLyoqXG4gKiBXaGVuIG1lcmdpbmcgZGVmYXVsdHMgYW5kIGZvcm0gZGF0YSwgd2Ugd2FudCB0byBtZXJnZSBpbiB0aGlzIHNwZWNpZmljIHdheTpcbiAqIC0gb2JqZWN0cyBhcmUgZGVlcGx5IG1lcmdlZFxuICogLSBhcnJheXMgYXJlIG1lcmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQ6XG4gKiAgIC0gd2hlbiB0aGUgYXJyYXkgaXMgc2V0IGluIGZvcm0gZGF0YSwgb25seSBhcnJheSBlbnRyaWVzIHNldCBpbiBmb3JtIGRhdGFcbiAqICAgICBhcmUgZGVlcGx5IG1lcmdlZDsgYWRkaXRpb25hbCBlbnRyaWVzIGZyb20gdGhlIGRlZmF1bHRzIGFyZSBpZ25vcmVkXG4gKiAgIC0gd2hlbiB0aGUgYXJyYXkgaXMgbm90IHNldCBpbiBmb3JtIGRhdGEsIHRoZSBkZWZhdWx0IGlzIGNvcGllZCBvdmVyXG4gKiAtIHNjYWxhcnMgYXJlIG92ZXJ3cml0dGVuL3NldCBieSBmb3JtIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVmYXVsdHNXaXRoRm9ybURhdGEoZGVmYXVsdHMsIGZvcm1EYXRhKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkZWZhdWx0cykpIHtcbiAgICAgIGRlZmF1bHRzID0gW107XG4gICAgfVxuICAgIHJldHVybiBmb3JtRGF0YS5tYXAoKHZhbHVlLCBpZHgpID0+IHtcbiAgICAgIGlmIChkZWZhdWx0c1tpZHhdKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhKGRlZmF1bHRzW2lkeF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmb3JtRGF0YSkpIHtcbiAgICBjb25zdCBhY2MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7IC8vIFByZXZlbnQgbXV0YXRpb24gb2Ygc291cmNlIG9iamVjdC5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybURhdGEpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGFjY1trZXldID0gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShcbiAgICAgICAgZGVmYXVsdHMgPyBkZWZhdWx0c1trZXldIDoge30sXG4gICAgICAgIGZvcm1EYXRhW2tleV1cbiAgICAgICk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIGFjYyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1EYXRhO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaU9wdGlvbnModWlTY2hlbWEpIHtcbiAgLy8gZ2V0IGFsbCBwYXNzZWQgb3B0aW9ucyBmcm9tIHVpOndpZGdldCwgdWk6b3B0aW9ucywgYW5kIHVpOjxvcHRpb25OYW1lPlxuICByZXR1cm4gT2JqZWN0LmtleXModWlTY2hlbWEpXG4gICAgLmZpbHRlcihrZXkgPT4ga2V5LmluZGV4T2YoXCJ1aTpcIikgPT09IDApXG4gICAgLnJlZHVjZSgob3B0aW9ucywga2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHVpU2NoZW1hW2tleV07XG4gICAgICBpZiAoa2V5ID09PSBcInVpOndpZGdldFwiICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJTZXR0aW5nIG9wdGlvbnMgdmlhIHVpOndpZGdldCBvYmplY3QgaXMgZGVwcmVjYXRlZCwgdXNlIHVpOm9wdGlvbnMgaW5zdGVhZFwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAuLi4odmFsdWUub3B0aW9ucyB8fCB7fSksXG4gICAgICAgICAgd2lkZ2V0OiB2YWx1ZS5jb21wb25lbnQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcInVpOm9wdGlvbnNcIiAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3B0aW9ucywgLi4udmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIFtrZXkuc3Vic3RyaW5nKDMpXTogdmFsdWUgfTtcbiAgICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TGFiZWwoc2NoZW1hLCB1aVNjaGVtYSwgcm9vdFNjaGVtYSkge1xuICBjb25zdCB1aU9wdGlvbnMgPSBnZXRVaU9wdGlvbnModWlTY2hlbWEpO1xuICBsZXQgeyBsYWJlbDogZGlzcGxheUxhYmVsID0gdHJ1ZSB9ID0gdWlPcHRpb25zO1xuICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZShzY2hlbWEpO1xuXG4gIGlmIChzY2hlbWFUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICBkaXNwbGF5TGFiZWwgPVxuICAgICAgaXNNdWx0aVNlbGVjdChzY2hlbWEsIHJvb3RTY2hlbWEpIHx8XG4gICAgICBpc0ZpbGVzQXJyYXkoc2NoZW1hLCB1aVNjaGVtYSwgcm9vdFNjaGVtYSk7XG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGRpc3BsYXlMYWJlbCA9IGZhbHNlO1xuICB9XG4gIGlmIChzY2hlbWFUeXBlID09PSBcImJvb2xlYW5cIiAmJiAhdWlTY2hlbWFbXCJ1aTp3aWRnZXRcIl0pIHtcbiAgICBkaXNwbGF5TGFiZWwgPSBmYWxzZTtcbiAgfVxuICBpZiAodWlTY2hlbWFbXCJ1aTpmaWVsZFwiXSkge1xuICAgIGRpc3BsYXlMYWJlbCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TGFiZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpbmcgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodGhpbmcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIsIGNvbmNhdEFycmF5cyA9IGZhbHNlKSB7XG4gIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIGRlZXBseSBuZXN0ZWQgb2JqZWN0cy5cbiAgdmFyIGFjYyA9IE9iamVjdC5hc3NpZ24oe30sIG9iajEpOyAvLyBQcmV2ZW50IG11dGF0aW9uIG9mIHNvdXJjZSBvYmplY3QuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmoyKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IG9iajEgPyBvYmoxW2tleV0gOiB7fSxcbiAgICAgIHJpZ2h0ID0gb2JqMltrZXldO1xuICAgIGlmIChvYmoxICYmIG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpc09iamVjdChyaWdodCkpIHtcbiAgICAgIGFjY1trZXldID0gbWVyZ2VPYmplY3RzKGxlZnQsIHJpZ2h0LCBjb25jYXRBcnJheXMpO1xuICAgIH0gZWxzZSBpZiAoY29uY2F0QXJyYXlzICYmIEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgIGFjY1trZXldID0gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba2V5XSA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBhY2MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoL1xcLiQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gXCIzLlwiIGNhbid0IHJlYWxseSBiZSBjb25zaWRlcmVkIGEgbnVtYmVyIGV2ZW4gaWYgaXQgcGFyc2VzIGluIGpzLiBUaGVcbiAgICAvLyB1c2VyIGlzIG1vc3QgbGlrZWx5IGVudGVyaW5nIGEgZmxvYXQuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICgvXFwuMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gdGhpcyBhcyBhIHN0cmluZyBoZXJlLCB0byBhbGxvdyBmb3IgaW5wdXQgbGlrZSAzLjA3XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IG4gPSBOdW1iZXIodmFsdWUpO1xuICBjb25zdCB2YWxpZCA9IHR5cGVvZiBuID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4obik7XG5cbiAgaWYgKC9cXC5cXGQqMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gSXQncyBhIG51bWJlciwgdGhhdCdzIGNvb2wgLSBidXQgd2UgbmVlZCBpdCBhcyBhIHN0cmluZyBzbyBpdCBkb2Vzbid0IHNjcmV3XG4gICAgLy8gd2l0aCB0aGUgdXNlciB3aGVuIGVudGVyaW5nIGRvbGxhciBhbW91bnRzIG9yIG90aGVyIHZhbHVlcyAoc3VjaCBhcyB0aG9zZSB3aXRoXG4gICAgLy8gc3BlY2lmaWMgcHJlY2lzaW9uIG9yIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMpXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkID8gbiA6IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIG9yZGVyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG4gIGNvbnN0IGFycmF5VG9IYXNoID0gYXJyID0+XG4gICAgYXJyLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgcHJldltjdXJyXSA9IHRydWU7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG4gIGNvbnN0IGVycm9yUHJvcExpc3QgPSBhcnIgPT5cbiAgICBhcnIubGVuZ3RoID4gMVxuICAgICAgPyBgcHJvcGVydGllcyAnJHthcnIuam9pbihcIicsICdcIil9J2BcbiAgICAgIDogYHByb3BlcnR5ICcke2FyclswXX0nYDtcbiAgY29uc3QgcHJvcGVydHlIYXNoID0gYXJyYXlUb0hhc2gocHJvcGVydGllcyk7XG4gIGNvbnN0IG9yZGVyRmlsdGVyZWQgPSBvcmRlci5maWx0ZXIoXG4gICAgcHJvcCA9PiBwcm9wID09PSBcIipcIiB8fCBwcm9wZXJ0eUhhc2hbcHJvcF1cbiAgKTtcbiAgY29uc3Qgb3JkZXJIYXNoID0gYXJyYXlUb0hhc2gob3JkZXJGaWx0ZXJlZCk7XG5cbiAgY29uc3QgcmVzdCA9IHByb3BlcnRpZXMuZmlsdGVyKHByb3AgPT4gIW9yZGVySGFzaFtwcm9wXSk7XG4gIGNvbnN0IHJlc3RJbmRleCA9IG9yZGVyRmlsdGVyZWQuaW5kZXhPZihcIipcIik7XG4gIGlmIChyZXN0SW5kZXggPT09IC0xKSB7XG4gICAgaWYgKHJlc3QubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB1aVNjaGVtYSBvcmRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gJHtlcnJvclByb3BMaXN0KHJlc3QpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBvcmRlckZpbHRlcmVkO1xuICB9XG4gIGlmIChyZXN0SW5kZXggIT09IG9yZGVyRmlsdGVyZWQubGFzdEluZGV4T2YoXCIqXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidWlTY2hlbWEgb3JkZXIgbGlzdCBjb250YWlucyBtb3JlIHRoYW4gb25lIHdpbGRjYXJkIGl0ZW1cIik7XG4gIH1cblxuICBjb25zdCBjb21wbGV0ZSA9IFsuLi5vcmRlckZpbHRlcmVkXTtcbiAgY29tcGxldGUuc3BsaWNlKHJlc3RJbmRleCwgMSwgLi4ucmVzdCk7XG4gIHJldHVybiBjb21wbGV0ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgZ2l2ZW4gc2NoZW1hIG1hdGNoZXMgYSBzaW5nbGVcbiAqIGNvbnN0YW50IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb25zdGFudChzY2hlbWEpIHtcbiAgcmV0dXJuIChcbiAgICAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB8fFxuICAgIHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImNvbnN0XCIpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0NvbnN0YW50KHNjaGVtYSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5lbnVtWzBdO1xuICB9IGVsc2UgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImNvbnN0XCIpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5jb25zdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgY2Fubm90IGJlIGluZmVycmVkIGFzIGEgY29uc3RhbnRcIik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VsZWN0KF9zY2hlbWEsIHJvb3RTY2hlbWEgPSB7fSkge1xuICBjb25zdCBzY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShfc2NoZW1hLCByb290U2NoZW1hKTtcbiAgY29uc3QgYWx0U2NoZW1hcyA9IHNjaGVtYS5vbmVPZiB8fCBzY2hlbWEuYW55T2Y7XG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWx0U2NoZW1hcykpIHtcbiAgICByZXR1cm4gYWx0U2NoZW1hcy5ldmVyeShhbHRTY2hlbWFzID0+IGlzQ29uc3RhbnQoYWx0U2NoZW1hcykpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTXVsdGlTZWxlY3Qoc2NoZW1hLCByb290U2NoZW1hID0ge30pIHtcbiAgaWYgKCFzY2hlbWEudW5pcXVlSXRlbXMgfHwgIXNjaGVtYS5pdGVtcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNTZWxlY3Qoc2NoZW1hLml0ZW1zLCByb290U2NoZW1hKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZXNBcnJheShzY2hlbWEsIHVpU2NoZW1hLCByb290U2NoZW1hID0ge30pIHtcbiAgaWYgKHVpU2NoZW1hW1widWk6d2lkZ2V0XCJdID09PSBcImZpbGVzXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaXRlbXMpIHtcbiAgICBjb25zdCBpdGVtc1NjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHNjaGVtYS5pdGVtcywgcm9vdFNjaGVtYSk7XG4gICAgcmV0dXJuIGl0ZW1zU2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgaXRlbXNTY2hlbWEuZm9ybWF0ID09PSBcImRhdGEtdXJsXCI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXhlZEl0ZW1zKHNjaGVtYSkge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSAmJlxuICAgIHNjaGVtYS5pdGVtcy5sZW5ndGggPiAwICYmXG4gICAgc2NoZW1hLml0ZW1zLmV2ZXJ5KGl0ZW0gPT4gaXNPYmplY3QoaXRlbSkpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxvd0FkZGl0aW9uYWxJdGVtcyhzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJhZGRpdGlvbmFsSXRlbXM9dHJ1ZSBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICByZXR1cm4gaXNPYmplY3Qoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25zTGlzdChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5lbnVtKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5lbnVtLm1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gKHNjaGVtYS5lbnVtTmFtZXMgJiYgc2NoZW1hLmVudW1OYW1lc1tpXSkgfHwgU3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB7IGxhYmVsLCB2YWx1ZSB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFsdFNjaGVtYXMgPSBzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mO1xuICAgIHJldHVybiBhbHRTY2hlbWFzLm1hcCgoc2NoZW1hLCBpKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRvQ29uc3RhbnQoc2NoZW1hKTtcbiAgICAgIGNvbnN0IGxhYmVsID0gc2NoZW1hLnRpdGxlIHx8IFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTY2hlbWFEZWZpbml0aW9uKCRyZWYsIHJvb3RTY2hlbWEgPSB7fSkge1xuICBjb25zdCBvcmlnUmVmID0gJHJlZjtcbiAgaWYgKCRyZWYuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAvLyBEZWNvZGUgVVJJIGZyYWdtZW50IHJlcHJlc2VudGF0aW9uLlxuICAgICRyZWYgPSBkZWNvZGVVUklDb21wb25lbnQoJHJlZi5zdWJzdHJpbmcoMSkpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZpbml0aW9uIGZvciAke29yaWdSZWZ9LmApO1xuICB9XG4gIGNvbnN0IGN1cnJlbnQgPSBqc29ucG9pbnRlci5nZXQocm9vdFNjaGVtYSwgJHJlZik7XG4gIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmaW5pdGlvbiBmb3IgJHtvcmlnUmVmfS5gKTtcbiAgfVxuICBpZiAoY3VycmVudC5oYXNPd25Qcm9wZXJ0eShcIiRyZWZcIikpIHtcbiAgICByZXR1cm4gZmluZFNjaGVtYURlZmluaXRpb24oY3VycmVudC4kcmVmLCByb290U2NoZW1hKTtcbiAgfVxuICByZXR1cm4gY3VycmVudDtcbn1cblxuLy8gSW4gdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSB0byBpbXBsaWNpdGx5IGNyZWF0ZSBhIHNjaGVtYSwgaXQgaXMgdXNlZnVsIHRvIGtub3cgd2hhdCB0eXBlIHRvIHVzZVxuLy8gIGJhc2VkIG9uIHRoZSBkYXRhIHdlIGFyZSBkZWZpbmluZ1xuZXhwb3J0IGNvbnN0IGd1ZXNzVHlwZSA9IGZ1bmN0aW9uIGd1ZXNzVHlwZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gIH1cbiAgLy8gRGVmYXVsdCB0byBzdHJpbmcgaWYgd2UgY2FuJ3QgZmlndXJlIGl0IG91dFxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBjcmVhdGUgbmV3IFwicHJvcGVydGllc1wiIGl0ZW1zIGZvciBlYWNoIGtleSBpbiBvdXIgZm9ybURhdGFcbmV4cG9ydCBmdW5jdGlvbiBzdHViRXhpc3RpbmdBZGRpdGlvbmFsUHJvcGVydGllcyhcbiAgc2NoZW1hLFxuICByb290U2NoZW1hID0ge30sXG4gIGZvcm1EYXRhID0ge31cbikge1xuICAvLyBDbG9uZSB0aGUgc2NoZW1hIHNvIHdlIGRvbid0IHJ1aW4gdGhlIGNvbnN1bWVyJ3Mgb3JpZ2luYWxcbiAgc2NoZW1hID0ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBwcm9wZXJ0aWVzOiB7IC4uLnNjaGVtYS5wcm9wZXJ0aWVzIH0sXG4gIH07XG5cbiAgT2JqZWN0LmtleXMoZm9ybURhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gTm8gbmVlZCB0byBzdHViLCBvdXIgc2NoZW1hIGFscmVhZHkgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFwiJHJlZlwiKSkge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSByZXRyaWV2ZVNjaGVtYShcbiAgICAgICAgeyAkcmVmOiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXNbXCIkcmVmXCJdIH0sXG4gICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgIGZvcm1EYXRhXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFwidHlwZVwiKSkge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSB7IC4uLnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHsgdHlwZTogZ3Vlc3NUeXBlKGZvcm1EYXRhW2tleV0pIH07XG4gICAgfVxuXG4gICAgLy8gVGhlIHR5cGUgb2Ygb3VyIG5ldyBrZXkgc2hvdWxkIG1hdGNoIHRoZSBhZGRpdGlvbmFsUHJvcGVydGllcyB2YWx1ZTtcbiAgICBzY2hlbWEucHJvcGVydGllc1trZXldID0gYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgLy8gU2V0IG91ciBhZGRpdGlvbmFsIHByb3BlcnR5IGZsYWcgc28gd2Uga25vdyBpdCB3YXMgZHluYW1pY2FsbHkgYWRkZWRcbiAgICBzY2hlbWEucHJvcGVydGllc1trZXldW0FERElUSU9OQUxfUFJPUEVSVFlfRkxBR10gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gc2NoZW1hO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShzY2hlbWEsIHJvb3RTY2hlbWEgPSB7fSwgZm9ybURhdGEgPSB7fSkge1xuICBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KFwiJHJlZlwiKSkge1xuICAgIHJldHVybiByZXNvbHZlUmVmZXJlbmNlKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICB9IGVsc2UgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImRlcGVuZGVuY2llc1wiKSkge1xuICAgIGNvbnN0IHJlc29sdmVkU2NoZW1hID0gcmVzb2x2ZURlcGVuZGVuY2llcyhzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICByZXR1cm4gcmV0cmlldmVTY2hlbWEocmVzb2x2ZWRTY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJhbGxPZlwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlbWEsXG4gICAgICBhbGxPZjogc2NoZW1hLmFsbE9mLm1hcChhbGxPZlN1YnNjaGVtYSA9PlxuICAgICAgICByZXRyaWV2ZVNjaGVtYShhbGxPZlN1YnNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpXG4gICAgICApLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gJHJlZiBvciBkZXBlbmRlbmNpZXMgYXR0cmlidXRlIGZvdW5kLCByZXR1cm5pbmcgdGhlIG9yaWdpbmFsIHNjaGVtYS5cbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2Uoc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSkge1xuICAvLyBSZXRyaWV2ZSB0aGUgcmVmZXJlbmNlZCBzY2hlbWEgZGVmaW5pdGlvbi5cbiAgY29uc3QgJHJlZlNjaGVtYSA9IGZpbmRTY2hlbWFEZWZpbml0aW9uKHNjaGVtYS4kcmVmLCByb290U2NoZW1hKTtcbiAgLy8gRHJvcCB0aGUgJHJlZiBwcm9wZXJ0eSBvZiB0aGUgc291cmNlIHNjaGVtYS5cbiAgY29uc3QgeyAkcmVmLCAuLi5sb2NhbFNjaGVtYSB9ID0gc2NoZW1hO1xuICAvLyBVcGRhdGUgcmVmZXJlbmNlZCBzY2hlbWEgZGVmaW5pdGlvbiB3aXRoIGxvY2FsIHNjaGVtYSBwcm9wZXJ0aWVzLlxuICByZXR1cm4gcmV0cmlldmVTY2hlbWEoXG4gICAgeyAuLi4kcmVmU2NoZW1hLCAuLi5sb2NhbFNjaGVtYSB9LFxuICAgIHJvb3RTY2hlbWEsXG4gICAgZm9ybURhdGFcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlU2NoZW1hKHNjaGVtYSwgcm9vdFNjaGVtYSA9IHt9LCBmb3JtRGF0YSA9IHt9KSB7XG4gIGlmICghaXNPYmplY3Qoc2NoZW1hKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSByZXNvbHZlU2NoZW1hKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICBpZiAoXCJhbGxPZlwiIGluIHNjaGVtYSkge1xuICAgIHRyeSB7XG4gICAgICByZXNvbHZlZFNjaGVtYSA9IG1lcmdlQWxsT2Yoe1xuICAgICAgICAuLi5yZXNvbHZlZFNjaGVtYSxcbiAgICAgICAgYWxsT2Y6IHJlc29sdmVkU2NoZW1hLmFsbE9mLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiY291bGQgbm90IG1lcmdlIHN1YnNjaGVtYXMgaW4gYWxsT2Y6XFxuXCIgKyBlKTtcbiAgICAgIGNvbnN0IHsgYWxsT2YsIC4uLnJlc29sdmVkU2NoZW1hV2l0aG91dEFsbE9mIH0gPSByZXNvbHZlZFNjaGVtYTtcbiAgICAgIHJldHVybiByZXNvbHZlZFNjaGVtYVdpdGhvdXRBbGxPZjtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFzQWRkaXRpb25hbFByb3BlcnRpZXMgPVxuICAgIHJlc29sdmVkU2NoZW1hLmhhc093blByb3BlcnR5KFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikgJiZcbiAgICByZXNvbHZlZFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAhPT0gZmFsc2U7XG4gIGlmIChoYXNBZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgIHJldHVybiBzdHViRXhpc3RpbmdBZGRpdGlvbmFsUHJvcGVydGllcyhcbiAgICAgIHJlc29sdmVkU2NoZW1hLFxuICAgICAgcm9vdFNjaGVtYSxcbiAgICAgIGZvcm1EYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZXBlbmRlbmNpZXMoc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSkge1xuICAvLyBEcm9wIHRoZSBkZXBlbmRlbmNpZXMgZnJvbSB0aGUgc291cmNlIHNjaGVtYS5cbiAgbGV0IHsgZGVwZW5kZW5jaWVzID0ge30sIC4uLnJlc29sdmVkU2NoZW1hIH0gPSBzY2hlbWE7XG4gIGlmIChcIm9uZU9mXCIgaW4gcmVzb2x2ZWRTY2hlbWEpIHtcbiAgICByZXNvbHZlZFNjaGVtYSA9XG4gICAgICByZXNvbHZlZFNjaGVtYS5vbmVPZltcbiAgICAgICAgZ2V0TWF0Y2hpbmdPcHRpb24oZm9ybURhdGEsIHJlc29sdmVkU2NoZW1hLm9uZU9mLCByb290U2NoZW1hKVxuICAgICAgXTtcbiAgfSBlbHNlIGlmIChcImFueU9mXCIgaW4gcmVzb2x2ZWRTY2hlbWEpIHtcbiAgICByZXNvbHZlZFNjaGVtYSA9XG4gICAgICByZXNvbHZlZFNjaGVtYS5hbnlPZltcbiAgICAgICAgZ2V0TWF0Y2hpbmdPcHRpb24oZm9ybURhdGEsIHJlc29sdmVkU2NoZW1hLmFueU9mLCByb290U2NoZW1hKVxuICAgICAgXTtcbiAgfVxuICByZXR1cm4gcHJvY2Vzc0RlcGVuZGVuY2llcyhcbiAgICBkZXBlbmRlbmNpZXMsXG4gICAgcmVzb2x2ZWRTY2hlbWEsXG4gICAgcm9vdFNjaGVtYSxcbiAgICBmb3JtRGF0YVxuICApO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0RlcGVuZGVuY2llcyhcbiAgZGVwZW5kZW5jaWVzLFxuICByZXNvbHZlZFNjaGVtYSxcbiAgcm9vdFNjaGVtYSxcbiAgZm9ybURhdGFcbikge1xuICAvLyBQcm9jZXNzIGRlcGVuZGVuY2llcyB1cGRhdGluZyB0aGUgbG9jYWwgc2NoZW1hIHByb3BlcnRpZXMgYXMgYXBwcm9wcmlhdGUuXG4gIGZvciAoY29uc3QgZGVwZW5kZW5jeUtleSBpbiBkZXBlbmRlbmNpZXMpIHtcbiAgICAvLyBTa2lwIHRoaXMgZGVwZW5kZW5jeSBpZiBpdHMgdHJpZ2dlciBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudC5cbiAgICBpZiAoZm9ybURhdGFbZGVwZW5kZW5jeUtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFNraXAgdGhpcyBkZXBlbmRlbmN5IGlmIGl0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgc2NoZW1hIChzdWNoIGFzIHdoZW4gZGVwZW5kZW5jeUtleSBpcyBpdHNlbGYgYSBoaWRkZW4gZGVwZW5kZW5jeS4pXG4gICAgaWYgKFxuICAgICAgcmVzb2x2ZWRTY2hlbWEucHJvcGVydGllcyAmJlxuICAgICAgIShkZXBlbmRlbmN5S2V5IGluIHJlc29sdmVkU2NoZW1hLnByb3BlcnRpZXMpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgW2RlcGVuZGVuY3lLZXldOiBkZXBlbmRlbmN5VmFsdWUsXG4gICAgICAuLi5yZW1haW5pbmdEZXBlbmRlbmNpZXNcbiAgICB9ID0gZGVwZW5kZW5jaWVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY3lWYWx1ZSkpIHtcbiAgICAgIHJlc29sdmVkU2NoZW1hID0gd2l0aERlcGVuZGVudFByb3BlcnRpZXMocmVzb2x2ZWRTY2hlbWEsIGRlcGVuZGVuY3lWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZXBlbmRlbmN5VmFsdWUpKSB7XG4gICAgICByZXNvbHZlZFNjaGVtYSA9IHdpdGhEZXBlbmRlbnRTY2hlbWEoXG4gICAgICAgIHJlc29sdmVkU2NoZW1hLFxuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgZGVwZW5kZW5jeUtleSxcbiAgICAgICAgZGVwZW5kZW5jeVZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzc0RlcGVuZGVuY2llcyhcbiAgICAgIHJlbWFpbmluZ0RlcGVuZGVuY2llcyxcbiAgICAgIHJlc29sdmVkU2NoZW1hLFxuICAgICAgcm9vdFNjaGVtYSxcbiAgICAgIGZvcm1EYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG59XG5cbmZ1bmN0aW9uIHdpdGhEZXBlbmRlbnRQcm9wZXJ0aWVzKHNjaGVtYSwgYWRkaXRpb25hbGx5UmVxdWlyZWQpIHtcbiAgaWYgKCFhZGRpdGlvbmFsbHlSZXF1aXJlZCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgY29uc3QgcmVxdWlyZWQgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZClcbiAgICA/IEFycmF5LmZyb20obmV3IFNldChbLi4uc2NoZW1hLnJlcXVpcmVkLCAuLi5hZGRpdGlvbmFsbHlSZXF1aXJlZF0pKVxuICAgIDogYWRkaXRpb25hbGx5UmVxdWlyZWQ7XG4gIHJldHVybiB7IC4uLnNjaGVtYSwgcmVxdWlyZWQ6IHJlcXVpcmVkIH07XG59XG5cbmZ1bmN0aW9uIHdpdGhEZXBlbmRlbnRTY2hlbWEoXG4gIHNjaGVtYSxcbiAgcm9vdFNjaGVtYSxcbiAgZm9ybURhdGEsXG4gIGRlcGVuZGVuY3lLZXksXG4gIGRlcGVuZGVuY3lWYWx1ZVxuKSB7XG4gIGxldCB7IG9uZU9mLCAuLi5kZXBlbmRlbnRTY2hlbWEgfSA9IHJldHJpZXZlU2NoZW1hKFxuICAgIGRlcGVuZGVuY3lWYWx1ZSxcbiAgICByb290U2NoZW1hLFxuICAgIGZvcm1EYXRhXG4gICk7XG4gIHNjaGVtYSA9IG1lcmdlU2NoZW1hcyhzY2hlbWEsIGRlcGVuZGVudFNjaGVtYSk7XG4gIC8vIFNpbmNlIGl0IGRvZXMgbm90IGNvbnRhaW4gb25lT2YsIHdlIHJldHVybiB0aGUgb3JpZ2luYWwgc2NoZW1hLlxuICBpZiAob25lT2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkob25lT2YpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkOiBpdCBpcyBzb21lICR7dHlwZW9mIG9uZU9mfSBpbnN0ZWFkIG9mIGFuIGFycmF5YCk7XG4gIH1cbiAgLy8gUmVzb2x2ZSAkcmVmcyBpbnNpZGUgb25lT2YuXG4gIGNvbnN0IHJlc29sdmVkT25lT2YgPSBvbmVPZi5tYXAoc3Vic2NoZW1hID0+XG4gICAgc3Vic2NoZW1hLmhhc093blByb3BlcnR5KFwiJHJlZlwiKVxuICAgICAgPyByZXNvbHZlUmVmZXJlbmNlKHN1YnNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpXG4gICAgICA6IHN1YnNjaGVtYVxuICApO1xuICByZXR1cm4gd2l0aEV4YWN0bHlPbmVTdWJzY2hlbWEoXG4gICAgc2NoZW1hLFxuICAgIHJvb3RTY2hlbWEsXG4gICAgZm9ybURhdGEsXG4gICAgZGVwZW5kZW5jeUtleSxcbiAgICByZXNvbHZlZE9uZU9mXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdpdGhFeGFjdGx5T25lU3Vic2NoZW1hKFxuICBzY2hlbWEsXG4gIHJvb3RTY2hlbWEsXG4gIGZvcm1EYXRhLFxuICBkZXBlbmRlbmN5S2V5LFxuICBvbmVPZlxuKSB7XG4gIGNvbnN0IHZhbGlkU3Vic2NoZW1hcyA9IG9uZU9mLmZpbHRlcihzdWJzY2hlbWEgPT4ge1xuICAgIGlmICghc3Vic2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBbZGVwZW5kZW5jeUtleV06IGNvbmRpdGlvblByb3BlcnR5U2NoZW1hIH0gPSBzdWJzY2hlbWEucHJvcGVydGllcztcbiAgICBpZiAoY29uZGl0aW9uUHJvcGVydHlTY2hlbWEpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvblNjaGVtYSA9IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIFtkZXBlbmRlbmN5S2V5XTogY29uZGl0aW9uUHJvcGVydHlTY2hlbWEsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IHZhbGlkYXRlRm9ybURhdGEoZm9ybURhdGEsIGNvbmRpdGlvblNjaGVtYSk7XG4gICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0pO1xuICBpZiAodmFsaWRTdWJzY2hlbWFzLmxlbmd0aCAhPT0gMSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiaWdub3Jpbmcgb25lT2YgaW4gZGVwZW5kZW5jaWVzIGJlY2F1c2UgdGhlcmUgaXNuJ3QgZXhhY3RseSBvbmUgc3Vic2NoZW1hIHRoYXQgaXMgdmFsaWRcIlxuICAgICk7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBjb25zdCBzdWJzY2hlbWEgPSB2YWxpZFN1YnNjaGVtYXNbMF07XG4gIGNvbnN0IHtcbiAgICBbZGVwZW5kZW5jeUtleV06IGNvbmRpdGlvblByb3BlcnR5U2NoZW1hLFxuICAgIC4uLmRlcGVuZGVudFN1YnNjaGVtYVxuICB9ID0gc3Vic2NoZW1hLnByb3BlcnRpZXM7XG4gIGNvbnN0IGRlcGVuZGVudFNjaGVtYSA9IHsgLi4uc3Vic2NoZW1hLCBwcm9wZXJ0aWVzOiBkZXBlbmRlbnRTdWJzY2hlbWEgfTtcbiAgcmV0dXJuIG1lcmdlU2NoZW1hcyhcbiAgICBzY2hlbWEsXG4gICAgcmV0cmlldmVTY2hlbWEoZGVwZW5kZW50U2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSlcbiAgKTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgbWVyZ2UgZGVlcGx5IG5lc3RlZCBzY2hlbWFzLlxuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBtZXJnZVNjaGVtYXMgYW5kIG1lcmdlT2JqZWN0c1xuLy8gaXMgdGhhdCBtZXJnZVNjaGVtYXMgb25seSBjb25jYXRzIGFycmF5cyBmb3Jcbi8vIHZhbHVlcyB1bmRlciB0aGUgXCJyZXF1aXJlZFwiIGtleXdvcmQsIGFuZCB3aGVuIGl0IGRvZXMsXG4vLyBpdCBkb2Vzbid0IGluY2x1ZGUgZHVwbGljYXRlIHZhbHVlcy5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVNjaGVtYXMob2JqMSwgb2JqMikge1xuICB2YXIgYWNjID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqMSk7IC8vIFByZXZlbnQgbXV0YXRpb24gb2Ygc291cmNlIG9iamVjdC5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iajIpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gb2JqMSA/IG9iajFba2V5XSA6IHt9LFxuICAgICAgcmlnaHQgPSBvYmoyW2tleV07XG4gICAgaWYgKG9iajEgJiYgb2JqMS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGlzT2JqZWN0KHJpZ2h0KSkge1xuICAgICAgYWNjW2tleV0gPSBtZXJnZVNjaGVtYXMobGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvYmoxICYmXG4gICAgICBvYmoyICYmXG4gICAgICAoZ2V0U2NoZW1hVHlwZShvYmoxKSA9PT0gXCJvYmplY3RcIiB8fCBnZXRTY2hlbWFUeXBlKG9iajIpID09PSBcIm9iamVjdFwiKSAmJlxuICAgICAga2V5ID09PSBcInJlcXVpcmVkXCIgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobGVmdCkgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkocmlnaHQpXG4gICAgKSB7XG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGR1cGxpY2F0ZSB2YWx1ZXMgd2hlbiBtZXJnaW5nXG4gICAgICAvLyBcInJlcXVpcmVkXCIgZmllbGRzLlxuICAgICAgYWNjW2tleV0gPSB1bmlvbihsZWZ0LCByaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1trZXldID0gcmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIGFjYyk7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXF1YWxzKGEsIGIsIGNhID0gW10sIGNiID0gW10pIHtcbiAgLy8gUGFydGlhbGx5IGV4dHJhY3RlZCBmcm9tIG5vZGUtZGVlcGVyIGFuZCBhZGFwdGVkIHRvIGV4Y2x1ZGUgY29tcGFyaXNvblxuICAvLyBjaGVja3MgZm9yIGZ1bmN0aW9ucy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL290aGl5bTIzL25vZGUtZGVlcGVyXG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gQXNzdW1lIGFsbCBmdW5jdGlvbnMgYXJlIGVxdWl2YWxlbnRcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Jqc2YtdGVhbS9yZWFjdC1qc29uc2NoZW1hLWZvcm0vaXNzdWVzLzI1NVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBiIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEuc291cmNlID09PSBiLnNvdXJjZSAmJlxuICAgICAgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmXG4gICAgICBhLm11bHRpbGluZSA9PT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgIGEubGFzdEluZGV4ID09PSBiLmxhc3RJbmRleCAmJlxuICAgICAgYS5pZ25vcmVDYXNlID09PSBiLmlnbm9yZUNhc2VcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzQXJndW1lbnRzKGEpIHx8IGlzQXJndW1lbnRzKGIpKSB7XG4gICAgaWYgKCEoaXNBcmd1bWVudHMoYSkgJiYgaXNBcmd1bWVudHMoYikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICByZXR1cm4gZGVlcEVxdWFscyhzbGljZS5jYWxsKGEpLCBzbGljZS5jYWxsKGIpLCBjYSwgY2IpO1xuICB9IGVsc2Uge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGthID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGV0IGtiID0gT2JqZWN0LmtleXMoYik7XG4gICAgLy8gZG9uJ3QgYm90aGVyIHdpdGggc3RhY2sgYWNyb2JhdGljcyBpZiB0aGVyZSdzIG5vdGhpbmcgdGhlcmVcbiAgICBpZiAoa2EubGVuZ3RoID09PSAwICYmIGtiLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjYWwgPSBjYS5sZW5ndGg7XG4gICAgd2hpbGUgKGNhbC0tKSB7XG4gICAgICBpZiAoY2FbY2FsXSA9PT0gYSkge1xuICAgICAgICByZXR1cm4gY2JbY2FsXSA9PT0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgY2EucHVzaChhKTtcbiAgICBjYi5wdXNoKGIpO1xuXG4gICAga2Euc29ydCgpO1xuICAgIGtiLnNvcnQoKTtcbiAgICBmb3IgKHZhciBqID0ga2EubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChrYVtqXSAhPT0ga2Jbal0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBrZXk7XG4gICAgZm9yIChsZXQgayA9IGthLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICBrZXkgPSBrYVtrXTtcbiAgICAgIGlmICghZGVlcEVxdWFscyhhW2tleV0sIGJba2V5XSwgY2EsIGNiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2EucG9wKCk7XG4gICAgY2IucG9wKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkUmVuZGVyKGNvbXAsIG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHN0YXRlIH0gPSBjb21wO1xuICByZXR1cm4gIWRlZXBFcXVhbHMocHJvcHMsIG5leHRQcm9wcykgfHwgIWRlZXBFcXVhbHMoc3RhdGUsIG5leHRTdGF0ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0lkU2NoZW1hKFxuICBzY2hlbWEsXG4gIGlkLFxuICByb290U2NoZW1hLFxuICBmb3JtRGF0YSA9IHt9LFxuICBpZFByZWZpeCA9IFwicm9vdFwiXG4pIHtcbiAgY29uc3QgaWRTY2hlbWEgPSB7XG4gICAgJGlkOiBpZCB8fCBpZFByZWZpeCxcbiAgfTtcbiAgaWYgKFwiJHJlZlwiIGluIHNjaGVtYSB8fCBcImRlcGVuZGVuY2llc1wiIGluIHNjaGVtYSB8fCBcImFsbE9mXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgX3NjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgIHJldHVybiB0b0lkU2NoZW1hKF9zY2hlbWEsIGlkLCByb290U2NoZW1hLCBmb3JtRGF0YSwgaWRQcmVmaXgpO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hICYmICFzY2hlbWEuaXRlbXMuJHJlZikge1xuICAgIHJldHVybiB0b0lkU2NoZW1hKHNjaGVtYS5pdGVtcywgaWQsIHJvb3RTY2hlbWEsIGZvcm1EYXRhLCBpZFByZWZpeCk7XG4gIH1cbiAgaWYgKHNjaGVtYS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGlkU2NoZW1hO1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEucHJvcGVydGllcyB8fCB7fSkge1xuICAgIGNvbnN0IGZpZWxkID0gc2NoZW1hLnByb3BlcnRpZXNbbmFtZV07XG4gICAgY29uc3QgZmllbGRJZCA9IGlkU2NoZW1hLiRpZCArIFwiX1wiICsgbmFtZTtcbiAgICBpZFNjaGVtYVtuYW1lXSA9IHRvSWRTY2hlbWEoXG4gICAgICBpc09iamVjdChmaWVsZCkgPyBmaWVsZCA6IHt9LFxuICAgICAgZmllbGRJZCxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZm9ybURhdGEgaXMgbm90IGFuIG9iamVjdCAtLSB0aGlzIGNhbiBoYXBwZW4gaWYgYW5cbiAgICAgIC8vIGFycmF5IGl0ZW0gaGFzIGp1c3QgYmVlbiBhZGRlZCwgYnV0IG5vdCBwb3B1bGF0ZWQgd2l0aCBkYXRhIHlldFxuICAgICAgKGZvcm1EYXRhIHx8IHt9KVtuYW1lXSxcbiAgICAgIGlkUHJlZml4XG4gICAgKTtcbiAgfVxuICByZXR1cm4gaWRTY2hlbWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BhdGhTY2hlbWEoc2NoZW1hLCBuYW1lID0gXCJcIiwgcm9vdFNjaGVtYSwgZm9ybURhdGEgPSB7fSkge1xuICBjb25zdCBwYXRoU2NoZW1hID0ge1xuICAgICRuYW1lOiBuYW1lLnJlcGxhY2UoL15cXC4vLCBcIlwiKSxcbiAgfTtcbiAgaWYgKFwiJHJlZlwiIGluIHNjaGVtYSB8fCBcImRlcGVuZGVuY2llc1wiIGluIHNjaGVtYSB8fCBcImFsbE9mXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgX3NjaGVtYSA9IHJldHJpZXZlU2NoZW1hKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICAgIHJldHVybiB0b1BhdGhTY2hlbWEoX3NjaGVtYSwgbmFtZSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKSB7XG4gICAgcGF0aFNjaGVtYS5fX3Jqc2ZfYWRkaXRpb25hbFByb3BlcnRpZXMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcIml0ZW1zXCIpICYmIEFycmF5LmlzQXJyYXkoZm9ybURhdGEpKSB7XG4gICAgZm9ybURhdGEuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4ge1xuICAgICAgcGF0aFNjaGVtYVtpXSA9IHRvUGF0aFNjaGVtYShcbiAgICAgICAgc2NoZW1hLml0ZW1zLFxuICAgICAgICBgJHtuYW1lfS4ke2l9YCxcbiAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgZWxlbWVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJwcm9wZXJ0aWVzXCIpKSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgcGF0aFNjaGVtYVtwcm9wZXJ0eV0gPSB0b1BhdGhTY2hlbWEoXG4gICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSxcbiAgICAgICAgYCR7bmFtZX0uJHtwcm9wZXJ0eX1gLFxuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZm9ybURhdGEgaXMgbm90IGFuIG9iamVjdCAtLSB0aGlzIGNhbiBoYXBwZW4gaWYgYW5cbiAgICAgICAgLy8gYXJyYXkgaXRlbSBoYXMganVzdCBiZWVuIGFkZGVkLCBidXQgbm90IHBvcHVsYXRlZCB3aXRoIGRhdGEgeWV0XG4gICAgICAgIChmb3JtRGF0YSB8fCB7fSlbcHJvcGVydHldXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aFNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGF0ZVN0cmluZyhkYXRlU3RyaW5nLCBpbmNsdWRlVGltZSA9IHRydWUpIHtcbiAgaWYgKCFkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IC0xLFxuICAgICAgbW9udGg6IC0xLFxuICAgICAgZGF5OiAtMSxcbiAgICAgIGhvdXI6IGluY2x1ZGVUaW1lID8gLTEgOiAwLFxuICAgICAgbWludXRlOiBpbmNsdWRlVGltZSA/IC0xIDogMCxcbiAgICAgIHNlY29uZDogaW5jbHVkZVRpbWUgPyAtMSA6IDAsXG4gICAgfTtcbiAgfVxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGRhdGUgXCIgKyBkYXRlU3RyaW5nKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHllYXI6IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZGF0ZS5nZXRVVENNb250aCgpICsgMSwgLy8gb2ggeW91LCBqYXZhc2NyaXB0LlxuICAgIGRheTogZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgaG91cjogaW5jbHVkZVRpbWUgPyBkYXRlLmdldFVUQ0hvdXJzKCkgOiAwLFxuICAgIG1pbnV0ZTogaW5jbHVkZVRpbWUgPyBkYXRlLmdldFVUQ01pbnV0ZXMoKSA6IDAsXG4gICAgc2Vjb25kOiBpbmNsdWRlVGltZSA/IGRhdGUuZ2V0VVRDU2Vjb25kcygpIDogMCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0ZVN0cmluZyhcbiAgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyID0gMCwgbWludXRlID0gMCwgc2Vjb25kID0gMCB9LFxuICB0aW1lID0gdHJ1ZVxuKSB7XG4gIGNvbnN0IHV0Y1RpbWUgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlKHV0Y1RpbWUpLnRvSlNPTigpO1xuICByZXR1cm4gdGltZSA/IGRhdGV0aW1lIDogZGF0ZXRpbWUuc2xpY2UoMCwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXRjVG9Mb2NhbChqc29uRGF0ZSkge1xuICBpZiAoIWpzb25EYXRlKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvLyByZXF1aXJlZCBmb3JtYXQgb2YgYFwieXl5eS1NTS1kZFRoaDptbVwiIGZvbGxvd2VkIGJ5IG9wdGlvbmFsIFwiOnNzXCIgb3IgXCI6c3MuU1NTXCJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNsb2NhbC1kYXRlLWFuZC10aW1lLXN0YXRlLSh0eXBlJTNEZGF0ZXRpbWUtbG9jYWwpXG4gIC8vID4gc2hvdWxkIGJlIGEgX3ZhbGlkIGxvY2FsIGRhdGUgYW5kIHRpbWUgc3RyaW5nXyAobm90IEdNVClcblxuICAvLyBOb3RlIC0gZGF0ZSBjb25zdHJ1Y3RvciBwYXNzZWQgbG9jYWwgSVNPLTg2MDEgZG9lcyBub3QgY29ycmVjdGx5XG4gIC8vIGNoYW5nZSB0aW1lIHRvIFVUQyBpbiBub2RlIHByZS04XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShqc29uRGF0ZSk7XG5cbiAgY29uc3QgeXl5eSA9IHBhZChkYXRlLmdldEZ1bGxZZWFyKCksIDQpO1xuICBjb25zdCBNTSA9IHBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcbiAgY29uc3QgZGQgPSBwYWQoZGF0ZS5nZXREYXRlKCksIDIpO1xuICBjb25zdCBoaCA9IHBhZChkYXRlLmdldEhvdXJzKCksIDIpO1xuICBjb25zdCBtbSA9IHBhZChkYXRlLmdldE1pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNzID0gcGFkKGRhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgY29uc3QgU1NTID0gcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuXG4gIHJldHVybiBgJHt5eXl5fS0ke01NfS0ke2RkfVQke2hofToke21tfToke3NzfS4ke1NTU31gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUb1VUQyhkYXRlU3RyaW5nKSB7XG4gIGlmIChkYXRlU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVTdHJpbmcpLnRvSlNPTigpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gIGxldCBzID0gU3RyaW5nKG51bSk7XG4gIHdoaWxlIChzLmxlbmd0aCA8IHNpemUpIHtcbiAgICBzID0gXCIwXCIgKyBzO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF0YVVSSXRvQmxvYihkYXRhVVJJKSB7XG4gIC8vIFNwbGl0IG1ldGFkYXRhIGZyb20gZGF0YVxuICBjb25zdCBzcGxpdHRlZCA9IGRhdGFVUkkuc3BsaXQoXCIsXCIpO1xuICAvLyBTcGxpdCBwYXJhbXNcbiAgY29uc3QgcGFyYW1zID0gc3BsaXR0ZWRbMF0uc3BsaXQoXCI7XCIpO1xuICAvLyBHZXQgbWltZS10eXBlIGZyb20gcGFyYW1zXG4gIGNvbnN0IHR5cGUgPSBwYXJhbXNbMF0ucmVwbGFjZShcImRhdGE6XCIsIFwiXCIpO1xuICAvLyBGaWx0ZXIgdGhlIG5hbWUgcHJvcGVydHkgZnJvbSBwYXJhbXNcbiAgY29uc3QgcHJvcGVydGllcyA9IHBhcmFtcy5maWx0ZXIocGFyYW0gPT4ge1xuICAgIHJldHVybiBwYXJhbS5zcGxpdChcIj1cIilbMF0gPT09IFwibmFtZVwiO1xuICB9KTtcbiAgLy8gTG9vayBmb3IgdGhlIG5hbWUgYW5kIHVzZSB1bmtub3duIGlmIG5vIG5hbWUgcHJvcGVydHkuXG4gIGxldCBuYW1lO1xuICBpZiAocHJvcGVydGllcy5sZW5ndGggIT09IDEpIHtcbiAgICBuYW1lID0gXCJ1bmtub3duXCI7XG4gIH0gZWxzZSB7XG4gICAgLy8gQmVjYXVzZSB3ZSBmaWx0ZXJlZCBvdXQgdGhlIG90aGVyIHByb3BlcnR5LFxuICAgIC8vIHdlIG9ubHkgaGF2ZSB0aGUgbmFtZSBjYXNlIGhlcmUuXG4gICAgbmFtZSA9IHByb3BlcnRpZXNbMF0uc3BsaXQoXCI9XCIpWzFdO1xuICB9XG5cbiAgLy8gQnVpbHQgdGhlIFVpbnQ4QXJyYXkgQmxvYiBwYXJhbWV0ZXIgZnJvbSB0aGUgYmFzZTY0IHN0cmluZy5cbiAgY29uc3QgYmluYXJ5ID0gYXRvYihzcGxpdHRlZFsxXSk7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaChiaW5hcnkuY2hhckNvZGVBdChpKSk7XG4gIH1cbiAgLy8gQ3JlYXRlIHRoZSBibG9iIG9iamVjdFxuICBjb25zdCBibG9iID0gbmV3IHdpbmRvdy5CbG9iKFtuZXcgVWludDhBcnJheShhcnJheSldLCB7IHR5cGUgfSk7XG5cbiAgcmV0dXJuIHsgYmxvYiwgbmFtZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VTcGVjKHNjaGVtYSkge1xuICBjb25zdCBzcGVjID0ge307XG4gIGlmIChzY2hlbWEubXVsdGlwbGVPZikge1xuICAgIHNwZWMuc3RlcCA9IHNjaGVtYS5tdWx0aXBsZU9mO1xuICB9XG4gIGlmIChzY2hlbWEubWluaW11bSB8fCBzY2hlbWEubWluaW11bSA9PT0gMCkge1xuICAgIHNwZWMubWluID0gc2NoZW1hLm1pbmltdW07XG4gIH1cbiAgaWYgKHNjaGVtYS5tYXhpbXVtIHx8IHNjaGVtYS5tYXhpbXVtID09PSAwKSB7XG4gICAgc3BlYy5tYXggPSBzY2hlbWEubWF4aW11bTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCBvcHRpb25zLCByb290U2NoZW1hKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgICAvLyBJZiB0aGUgc2NoZW1hIGRlc2NyaWJlcyBhbiBvYmplY3QgdGhlbiB3ZSBuZWVkIHRvIGFkZCBzbGlnaHRseSBtb3JlXG4gICAgLy8gc3RyaWN0IG1hdGNoaW5nIHRvIHRoZSBzY2hlbWEsIGJlY2F1c2UgdW5sZXNzIHRoZSBzY2hlbWEgdXNlcyB0aGVcbiAgICAvLyBcInJlcXVpcmVzXCIga2V5d29yZCwgYW4gb2JqZWN0IHdpbGwgbWF0Y2ggdGhlIHNjaGVtYSBhcyBsb25nIGFzIGl0XG4gICAgLy8gZG9lc24ndCBoYXZlIG1hdGNoaW5nIGtleXMgd2l0aCBhIGNvbmZsaWN0aW5nIHR5cGUuIFRvIGRvIHRoaXMgd2UgdXNlIGFuXG4gICAgLy8gXCJhbnlPZlwiIHdpdGggYW4gYXJyYXkgb2YgcmVxdWlyZXMuIFRoaXMgYXVnbWVudGF0aW9uIGV4cHJlc3NlcyB0aGF0IHRoZVxuICAgIC8vIHNjaGVtYSBzaG91bGQgbWF0Y2ggaWYgYW55IG9mIHRoZSBrZXlzIGluIHRoZSBzY2hlbWEgYXJlIHByZXNlbnQgb24gdGhlXG4gICAgLy8gb2JqZWN0IGFuZCBwYXNzIHZhbGlkYXRpb24uXG4gICAgaWYgKG9wdGlvbi5wcm9wZXJ0aWVzKSB7XG4gICAgICAvLyBDcmVhdGUgYW4gXCJhbnlPZlwiIHNjaGVtYSB0aGF0IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvZiB0aGUga2V5cyBpbiB0aGVcbiAgICAgIC8vIFwicHJvcGVydGllc1wiIG9iamVjdFxuICAgICAgY29uc3QgcmVxdWlyZXNBbnlPZiA9IHtcbiAgICAgICAgYW55T2Y6IE9iamVjdC5rZXlzKG9wdGlvbi5wcm9wZXJ0aWVzKS5tYXAoa2V5ID0+ICh7XG4gICAgICAgICAgcmVxdWlyZWQ6IFtrZXldLFxuICAgICAgICB9KSksXG4gICAgICB9O1xuXG4gICAgICBsZXQgYXVnbWVudGVkU2NoZW1hO1xuXG4gICAgICAvLyBJZiB0aGUgXCJhbnlPZlwiIGtleXdvcmQgYWxyZWFkeSBleGlzdHMsIHdyYXAgdGhlIGF1Z21lbnRhdGlvbiBpbiBhbiBcImFsbE9mXCJcbiAgICAgIGlmIChvcHRpb24uYW55T2YpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgb3B0aW9uXG4gICAgICAgIGNvbnN0IHsgLi4uc2hhbGxvd0Nsb25lIH0gPSBvcHRpb247XG5cbiAgICAgICAgaWYgKCFzaGFsbG93Q2xvbmUuYWxsT2YpIHtcbiAgICAgICAgICBzaGFsbG93Q2xvbmUuYWxsT2YgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBcImFsbE9mXCIgYWxyZWFkeSBleGlzdHMsIHNoYWxsb3cgY2xvbmUgdGhlIGFycmF5XG4gICAgICAgICAgc2hhbGxvd0Nsb25lLmFsbE9mID0gc2hhbGxvd0Nsb25lLmFsbE9mLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzaGFsbG93Q2xvbmUuYWxsT2YucHVzaChyZXF1aXJlc0FueU9mKTtcblxuICAgICAgICBhdWdtZW50ZWRTY2hlbWEgPSBzaGFsbG93Q2xvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWdtZW50ZWRTY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb24sIHJlcXVpcmVzQW55T2YpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIFwicmVxdWlyZWRcIiBmaWVsZCBhcyBpdCdzIGxpa2VseSB0aGF0IG5vdCBhbGwgZmllbGRzIGhhdmVcbiAgICAgIC8vIGJlZW4gZmlsbGVkIGluIHlldCwgd2hpY2ggd2lsbCBtZWFuIHRoYXQgdGhlIHNjaGVtYSBpcyBub3QgdmFsaWRcbiAgICAgIGRlbGV0ZSBhdWdtZW50ZWRTY2hlbWEucmVxdWlyZWQ7XG5cbiAgICAgIGlmIChpc1ZhbGlkKGF1Z21lbnRlZFNjaGVtYSwgZm9ybURhdGEsIHJvb3RTY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZChvcHRpb24sIGZvcm1EYXRhLCByb290U2NoZW1hKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBDaGVjayB0byBzZWUgaWYgYSBzY2hlbWEgc3BlY2lmaWVzIHRoYXQgYSB2YWx1ZSBtdXN0IGJlIHRydWVcbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZShzY2hlbWEpIHtcbiAgLy8gQ2hlY2sgaWYgY29uc3QgaXMgYSB0cnV0aHkgdmFsdWVcbiAgaWYgKHNjaGVtYS5jb25zdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW4gZW51bSBoYXMgYSBzaW5nbGUgdmFsdWUgb2YgdHJ1ZVxuICBpZiAoc2NoZW1hLmVudW0gJiYgc2NoZW1hLmVudW0ubGVuZ3RoID09PSAxICYmIHNjaGVtYS5lbnVtWzBdID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiBhbnlPZiBoYXMgYSBzaW5nbGUgdmFsdWUsIGV2YWx1YXRlIHRoZSBzdWJzY2hlbWFcbiAgaWYgKHNjaGVtYS5hbnlPZiAmJiBzY2hlbWEuYW55T2YubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKHNjaGVtYS5hbnlPZlswXSk7XG4gIH1cblxuICAvLyBJZiBvbmVPZiBoYXMgYSBzaW5nbGUgdmFsdWUsIGV2YWx1YXRlIHRoZSBzdWJzY2hlbWFcbiAgaWYgKHNjaGVtYS5vbmVPZiAmJiBzY2hlbWEub25lT2YubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKHNjaGVtYS5vbmVPZlswXSk7XG4gIH1cblxuICAvLyBFdmFsdWF0ZSBlYWNoIHN1YnNjaGVtYSBpbiBhbGxPZiwgdG8gc2VlIGlmIG9uZSBvZiB0aGVtIHJlcXVpcmVzIGEgdHJ1ZVxuICAvLyB2YWx1ZVxuICBpZiAoc2NoZW1hLmFsbE9mKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5zb21lKHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiJdfQ==