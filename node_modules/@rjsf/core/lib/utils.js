function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from "react";
import * as ReactIs from "react-is";
import mergeAllOf from "json-schema-merge-allof";
import fill from "core-js-pure/features/array/fill";
import union from "lodash/union";
import jsonpointer from "jsonpointer";
import fields from "./components/fields";
import widgets from "./components/widgets";
import validateFormData, { isValid } from "./validate";
export var ADDITIONAL_PROPERTY_FLAG = "__additional_property";
var widgetMap = {
  "boolean": {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
export function canExpand(schema, uiSchema, formData) {
  if (!schema.additionalProperties) {
    return false;
  }

  var _getUiOptions = getUiOptions(uiSchema),
      expandable = _getUiOptions.expandable;

  if (expandable === false) {
    return expandable;
  } // if ui:options.expandable was not explicitly set to false, we can add
  // another property if we have not exceeded maxProperties yet


  if (schema.maxProperties !== undefined) {
    return Object.keys(formData).length < schema.maxProperties;
  }

  return true;
}
export function getDefaultRegistry() {
  return {
    fields: fields,
    widgets: widgets,
    definitions: {},
    rootSchema: {},
    formContext: {}
  };
}
/* Gets the type of a given schema. */

export function getSchemaType(schema) {
  var type = schema.type;

  if (!type && schema["const"]) {
    return guessType(schema["const"]);
  }

  if (!type && schema["enum"]) {
    return "string";
  }

  if (!type && (schema.properties || schema.additionalProperties)) {
    return "object";
  }

  if (type instanceof Array && type.length === 2 && type.includes("null")) {
    return type.find(function (type) {
      return type !== "null";
    });
  }

  return type;
}
export function getWidget(schema, widget) {
  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var type = getSchemaType(schema);

  function mergeOptions(Widget) {
    // cache return value as property of widget for proper react reconciliation
    if (!Widget.MergedWidget) {
      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};

      Widget.MergedWidget = function (_ref) {
        var _ref$options = _ref.options,
            options = _ref$options === void 0 ? {} : _ref$options,
            props = _objectWithoutProperties(_ref, ["options"]);

        return React.createElement(Widget, _extends({
          options: _objectSpread({}, defaultOptions, options)
        }, props));
      };
    }

    return Widget.MergedWidget;
  }

  if (typeof widget === "function" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {
    return mergeOptions(widget);
  }

  if (typeof widget !== "string") {
    throw new Error("Unsupported widget definition: ".concat(_typeof(widget)));
  }

  if (registeredWidgets.hasOwnProperty(widget)) {
    var registeredWidget = registeredWidgets[widget];
    return getWidget(schema, registeredWidget, registeredWidgets);
  }

  if (!widgetMap.hasOwnProperty(type)) {
    throw new Error("No widget for type \"".concat(type, "\""));
  }

  if (widgetMap[type].hasOwnProperty(widget)) {
    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];
    return getWidget(schema, _registeredWidget, registeredWidgets);
  }

  throw new Error("No widget \"".concat(widget, "\" for type \"").concat(type, "\""));
}
export function hasWidget(schema, widget) {
  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  try {
    getWidget(schema, widget, registeredWidgets);
    return true;
  } catch (e) {
    if (e.message && (e.message.startsWith("No widget") || e.message.startsWith("Unsupported widget"))) {
      return false;
    }

    throw e;
  }
}

function computeDefaults(_schema, parentDefaults, rootSchema) {
  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var schema = isObject(_schema) ? _schema : {};
  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.

  var defaults = parentDefaults;

  if (isObject(defaults) && isObject(schema["default"])) {
    // For object defaults, only override parent defaults that are defined in
    // schema.default.
    defaults = mergeObjects(defaults, schema["default"]);
  } else if ("default" in schema) {
    // Use schema defaults for this node.
    defaults = schema["default"];
  } else if ("$ref" in schema) {
    // Use referenced schema defaults for this node.
    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);
    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if ("dependencies" in schema) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);
  } else if (isFixedItems(schema)) {
    defaults = schema.items.map(function (itemSchema, idx) {
      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);
    });
  } else if ("oneOf" in schema) {
    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];
  } else if ("anyOf" in schema) {
    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];
  } // Not defaults defined for this node, fallback to generic typed ones.


  if (typeof defaults === "undefined") {
    defaults = schema["default"];
  }

  switch (getSchemaType(schema)) {
    // We need to recur for object schema inner default values.
    case "object":
      return Object.keys(schema.properties || {}).reduce(function (acc, key) {
        // Compute the defaults for this node, with the parent defaults we might
        // have from a previous run: defaults[key].
        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);

        if (includeUndefinedValues || computedDefault !== undefined) {
          acc[key] = computedDefault;
        }

        return acc;
      }, {});

    case "array":
      // Inject defaults into existing array defaults
      if (Array.isArray(defaults)) {
        defaults = defaults.map(function (item, idx) {
          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);
        });
      } // Deeply inject defaults into already existing form data


      if (Array.isArray(rawFormData)) {
        defaults = rawFormData.map(function (item, idx) {
          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);
        });
      }

      if (schema.minItems) {
        if (!isMultiSelect(schema, rootSchema)) {
          var defaultsLength = defaults ? defaults.length : 0;

          if (schema.minItems > defaultsLength) {
            var defaultEntries = defaults || []; // populate the array with the defaults

            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;
            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems

            return defaultEntries.concat(fillerEntries);
          }
        } else {
          return defaults ? defaults : [];
        }
      }

  }

  return defaults;
}

export function getDefaultFormState(_schema, formData) {
  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (!isObject(_schema)) {
    throw new Error("Invalid schema: " + _schema);
  }

  var schema = retrieveSchema(_schema, rootSchema, formData);
  var defaults = computeDefaults(schema, _schema["default"], rootSchema, formData, includeUndefinedValues);

  if (typeof formData === "undefined") {
    // No form data? Use schema defaults.
    return defaults;
  }

  if (isObject(formData) || Array.isArray(formData)) {
    return mergeDefaultsWithFormData(defaults, formData);
  }

  if (formData === 0 || formData === false || formData === "") {
    return formData;
  }

  return formData || defaults;
}
/**
 * When merging defaults and form data, we want to merge in this specific way:
 * - objects are deeply merged
 * - arrays are merged in such a way that:
 *   - when the array is set in form data, only array entries set in form data
 *     are deeply merged; additional entries from the defaults are ignored
 *   - when the array is not set in form data, the default is copied over
 * - scalars are overwritten/set by form data
 */

export function mergeDefaultsWithFormData(defaults, formData) {
  if (Array.isArray(formData)) {
    if (!Array.isArray(defaults)) {
      defaults = [];
    }

    return formData.map(function (value, idx) {
      if (defaults[idx]) {
        return mergeDefaultsWithFormData(defaults[idx], value);
      }

      return value;
    });
  } else if (isObject(formData)) {
    var acc = Object.assign({}, defaults); // Prevent mutation of source object.

    return Object.keys(formData).reduce(function (acc, key) {
      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);
      return acc;
    }, acc);
  } else {
    return formData;
  }
}
export function getUiOptions(uiSchema) {
  // get all passed options from ui:widget, ui:options, and ui:<optionName>
  return Object.keys(uiSchema).filter(function (key) {
    return key.indexOf("ui:") === 0;
  }).reduce(function (options, key) {
    var value = uiSchema[key];

    if (key === "ui:widget" && isObject(value)) {
      console.warn("Setting options via ui:widget object is deprecated, use ui:options instead");
      return _objectSpread({}, options, value.options || {}, {
        widget: value.component
      });
    }

    if (key === "ui:options" && isObject(value)) {
      return _objectSpread({}, options, value);
    }

    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));
  }, {});
}
export function getDisplayLabel(schema, uiSchema, rootSchema) {
  var uiOptions = getUiOptions(uiSchema);
  var _uiOptions$label = uiOptions.label,
      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;
  var schemaType = getSchemaType(schema);

  if (schemaType === "array") {
    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);
  }

  if (schemaType === "object") {
    displayLabel = false;
  }

  if (schemaType === "boolean" && !uiSchema["ui:widget"]) {
    displayLabel = false;
  }

  if (uiSchema["ui:field"]) {
    displayLabel = false;
  }

  return displayLabel;
}
export function isObject(thing) {
  if (typeof File !== "undefined" && thing instanceof File) {
    return false;
  }

  return _typeof(thing) === "object" && thing !== null && !Array.isArray(thing);
}
export function mergeObjects(obj1, obj2) {
  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // Recursively merge deeply nested objects.
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeObjects(left, right, concatArrays);
    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {
      acc[key] = left.concat(right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}
export function asNumber(value) {
  if (value === "") {
    return undefined;
  }

  if (value === null) {
    return null;
  }

  if (/\.$/.test(value)) {
    // "3." can't really be considered a number even if it parses in js. The
    // user is most likely entering a float.
    return value;
  }

  if (/\.0$/.test(value)) {
    // we need to return this as a string here, to allow for input like 3.07
    return value;
  }

  var n = Number(value);
  var valid = typeof n === "number" && !Number.isNaN(n);

  if (/\.\d*0$/.test(value)) {
    // It's a number, that's cool - but we need it as a string so it doesn't screw
    // with the user when entering dollar amounts or other values (such as those with
    // specific precision or number of significant digits)
    return value;
  }

  return valid ? n : value;
}
export function orderProperties(properties, order) {
  if (!Array.isArray(order)) {
    return properties;
  }

  var arrayToHash = function arrayToHash(arr) {
    return arr.reduce(function (prev, curr) {
      prev[curr] = true;
      return prev;
    }, {});
  };

  var errorPropList = function errorPropList(arr) {
    return arr.length > 1 ? "properties '".concat(arr.join("', '"), "'") : "property '".concat(arr[0], "'");
  };

  var propertyHash = arrayToHash(properties);
  var orderFiltered = order.filter(function (prop) {
    return prop === "*" || propertyHash[prop];
  });
  var orderHash = arrayToHash(orderFiltered);
  var rest = properties.filter(function (prop) {
    return !orderHash[prop];
  });
  var restIndex = orderFiltered.indexOf("*");

  if (restIndex === -1) {
    if (rest.length) {
      throw new Error("uiSchema order list does not contain ".concat(errorPropList(rest)));
    }

    return orderFiltered;
  }

  if (restIndex !== orderFiltered.lastIndexOf("*")) {
    throw new Error("uiSchema order list contains more than one wildcard item");
  }

  var complete = _toConsumableArray(orderFiltered);

  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));
  return complete;
}
/**
 * This function checks if the given schema matches a single
 * constant value.
 */

export function isConstant(schema) {
  return Array.isArray(schema["enum"]) && schema["enum"].length === 1 || schema.hasOwnProperty("const");
}
export function toConstant(schema) {
  if (Array.isArray(schema["enum"]) && schema["enum"].length === 1) {
    return schema["enum"][0];
  } else if (schema.hasOwnProperty("const")) {
    return schema["const"];
  } else {
    throw new Error("schema cannot be inferred as a constant");
  }
}
export function isSelect(_schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var schema = retrieveSchema(_schema, rootSchema);
  var altSchemas = schema.oneOf || schema.anyOf;

  if (Array.isArray(schema["enum"])) {
    return true;
  } else if (Array.isArray(altSchemas)) {
    return altSchemas.every(function (altSchemas) {
      return isConstant(altSchemas);
    });
  }

  return false;
}
export function isMultiSelect(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!schema.uniqueItems || !schema.items) {
    return false;
  }

  return isSelect(schema.items, rootSchema);
}
export function isFilesArray(schema, uiSchema) {
  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (uiSchema["ui:widget"] === "files") {
    return true;
  } else if (schema.items) {
    var itemsSchema = retrieveSchema(schema.items, rootSchema);
    return itemsSchema.type === "string" && itemsSchema.format === "data-url";
  }

  return false;
}
export function isFixedItems(schema) {
  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {
    return isObject(item);
  });
}
export function allowAdditionalItems(schema) {
  if (schema.additionalItems === true) {
    console.warn("additionalItems=true is currently not supported");
  }

  return isObject(schema.additionalItems);
}
export function optionsList(schema) {
  if (schema["enum"]) {
    return schema["enum"].map(function (value, i) {
      var label = schema.enumNames && schema.enumNames[i] || String(value);
      return {
        label: label,
        value: value
      };
    });
  } else {
    var altSchemas = schema.oneOf || schema.anyOf;
    return altSchemas.map(function (schema, i) {
      var value = toConstant(schema);
      var label = schema.title || String(value);
      return {
        schema: schema,
        label: label,
        value: value
      };
    });
  }
}
export function findSchemaDefinition($ref) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var origRef = $ref;

  if ($ref.startsWith("#")) {
    // Decode URI fragment representation.
    $ref = decodeURIComponent($ref.substring(1));
  } else {
    throw new Error("Could not find a definition for ".concat(origRef, "."));
  }

  var current = jsonpointer.get(rootSchema, $ref);

  if (current === undefined) {
    throw new Error("Could not find a definition for ".concat(origRef, "."));
  }

  if (current.hasOwnProperty("$ref")) {
    return findSchemaDefinition(current.$ref, rootSchema);
  }

  return current;
} // In the case where we have to implicitly create a schema, it is useful to know what type to use
//  based on the data we are defining

export var guessType = function guessType(value) {
  if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "string") {
    return "string";
  } else if (value == null) {
    return "null";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (!isNaN(value)) {
    return "number";
  } else if (_typeof(value) === "object") {
    return "object";
  } // Default to string if we can't figure it out


  return "string";
}; // This function will create new "properties" items for each key in our formData

export function stubExistingAdditionalProperties(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Clone the schema so we don't ruin the consumer's original
  schema = _objectSpread({}, schema, {
    properties: _objectSpread({}, schema.properties)
  });
  Object.keys(formData).forEach(function (key) {
    if (schema.properties.hasOwnProperty(key)) {
      // No need to stub, our schema already has the property
      return;
    }

    var additionalProperties;

    if (schema.additionalProperties.hasOwnProperty("$ref")) {
      additionalProperties = retrieveSchema({
        $ref: schema.additionalProperties["$ref"]
      }, rootSchema, formData);
    } else if (schema.additionalProperties.hasOwnProperty("type")) {
      additionalProperties = _objectSpread({}, schema.additionalProperties);
    } else {
      additionalProperties = {
        type: guessType(formData[key])
      };
    } // The type of our new key should match the additionalProperties value;


    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added

    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;
  });
  return schema;
}
export function resolveSchema(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (schema.hasOwnProperty("$ref")) {
    return resolveReference(schema, rootSchema, formData);
  } else if (schema.hasOwnProperty("dependencies")) {
    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);
    return retrieveSchema(resolvedSchema, rootSchema, formData);
  } else if (schema.hasOwnProperty("allOf")) {
    return _objectSpread({}, schema, {
      allOf: schema.allOf.map(function (allOfSubschema) {
        return retrieveSchema(allOfSubschema, rootSchema, formData);
      })
    });
  } else {
    // No $ref or dependencies attribute found, returning the original schema.
    return schema;
  }
}

function resolveReference(schema, rootSchema, formData) {
  // Retrieve the referenced schema definition.
  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.

  var $ref = schema.$ref,
      localSchema = _objectWithoutProperties(schema, ["$ref"]); // Update referenced schema definition with local schema properties.


  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);
}

export function retrieveSchema(schema) {
  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!isObject(schema)) {
    return {};
  }

  var resolvedSchema = resolveSchema(schema, rootSchema, formData);

  if ("allOf" in schema) {
    try {
      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {
        allOf: resolvedSchema.allOf
      }));
    } catch (e) {
      console.warn("could not merge subschemas in allOf:\n" + e);

      var _resolvedSchema = resolvedSchema,
          allOf = _resolvedSchema.allOf,
          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, ["allOf"]);

      return resolvedSchemaWithoutAllOf;
    }
  }

  var hasAdditionalProperties = resolvedSchema.hasOwnProperty("additionalProperties") && resolvedSchema.additionalProperties !== false;

  if (hasAdditionalProperties) {
    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function resolveDependencies(schema, rootSchema, formData) {
  // Drop the dependencies from the source schema.
  var _schema$dependencies = schema.dependencies,
      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,
      resolvedSchema = _objectWithoutProperties(schema, ["dependencies"]);

  if ("oneOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];
  } else if ("anyOf" in resolvedSchema) {
    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];
  }

  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);
}

function processDependencies(dependencies, resolvedSchema, rootSchema, formData) {
  // Process dependencies updating the local schema properties as appropriate.
  for (var dependencyKey in dependencies) {
    // Skip this dependency if its trigger property is not present.
    if (formData[dependencyKey] === undefined) {
      continue;
    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)


    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {
      continue;
    }

    var dependencyValue = dependencies[dependencyKey],
        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));

    if (Array.isArray(dependencyValue)) {
      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);
    } else if (isObject(dependencyValue)) {
      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);
    }

    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);
  }

  return resolvedSchema;
}

function withDependentProperties(schema, additionallyRequired) {
  if (!additionallyRequired) {
    return schema;
  }

  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;
  return _objectSpread({}, schema, {
    required: required
  });
}

function withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {
  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),
      oneOf = _retrieveSchema.oneOf,
      dependentSchema = _objectWithoutProperties(_retrieveSchema, ["oneOf"]);

  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.

  if (oneOf === undefined) {
    return schema;
  } else if (!Array.isArray(oneOf)) {
    throw new Error("invalid: it is some ".concat(_typeof(oneOf), " instead of an array"));
  } // Resolve $refs inside oneOf.


  var resolvedOneOf = oneOf.map(function (subschema) {
    return subschema.hasOwnProperty("$ref") ? resolveReference(subschema, rootSchema, formData) : subschema;
  });
  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);
}

function withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {
  var validSubschemas = oneOf.filter(function (subschema) {
    if (!subschema.properties) {
      return false;
    }

    var conditionPropertySchema = subschema.properties[dependencyKey];

    if (conditionPropertySchema) {
      var conditionSchema = {
        type: "object",
        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)
      };

      var _validateFormData = validateFormData(formData, conditionSchema),
          errors = _validateFormData.errors;

      return errors.length === 0;
    }
  });

  if (validSubschemas.length !== 1) {
    console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid");
    return schema;
  }

  var subschema = validSubschemas[0];

  var _subschema$properties = subschema.properties,
      conditionPropertySchema = _subschema$properties[dependencyKey],
      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));

  var dependentSchema = _objectSpread({}, subschema, {
    properties: dependentSubschema
  });

  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));
} // Recursively merge deeply nested schemas.
// The difference between mergeSchemas and mergeObjects
// is that mergeSchemas only concats arrays for
// values under the "required" keyword, and when it does,
// it doesn't include duplicate values.


export function mergeSchemas(obj1, obj2) {
  var acc = Object.assign({}, obj1); // Prevent mutation of source object.

  return Object.keys(obj2).reduce(function (acc, key) {
    var left = obj1 ? obj1[key] : {},
        right = obj2[key];

    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {
      acc[key] = mergeSchemas(left, right);
    } else if (obj1 && obj2 && (getSchemaType(obj1) === "object" || getSchemaType(obj2) === "object") && key === "required" && Array.isArray(left) && Array.isArray(right)) {
      // Don't include duplicate values when merging
      // "required" fields.
      acc[key] = union(left, right);
    } else {
      acc[key] = right;
    }

    return acc;
  }, acc);
}

function isArguments(object) {
  return Object.prototype.toString.call(object) === "[object Arguments]";
}

export function deepEquals(a, b) {
  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  // Partially extracted from node-deeper and adapted to exclude comparison
  // checks for functions.
  // https://github.com/othiym23/node-deeper
  if (a === b) {
    return true;
  } else if (typeof a === "function" || typeof b === "function") {
    // Assume all functions are equivalent
    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255
    return true;
  } else if (_typeof(a) !== "object" || _typeof(b) !== "object") {
    return false;
  } else if (a === null || b === null) {
    return false;
  } else if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  } else if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;
  } else if (isArguments(a) || isArguments(b)) {
    if (!(isArguments(a) && isArguments(b))) {
      return false;
    }

    var slice = Array.prototype.slice;
    return deepEquals(slice.call(a), slice.call(b), ca, cb);
  } else {
    if (a.constructor !== b.constructor) {
      return false;
    }

    var ka = Object.keys(a);
    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there

    if (ka.length === 0 && kb.length === 0) {
      return true;
    }

    if (ka.length !== kb.length) {
      return false;
    }

    var cal = ca.length;

    while (cal--) {
      if (ca[cal] === a) {
        return cb[cal] === b;
      }
    }

    ca.push(a);
    cb.push(b);
    ka.sort();
    kb.sort();

    for (var j = ka.length - 1; j >= 0; j--) {
      if (ka[j] !== kb[j]) {
        return false;
      }
    }

    var _key;

    for (var k = ka.length - 1; k >= 0; k--) {
      _key = ka[k];

      if (!deepEquals(a[_key], b[_key], ca, cb)) {
        return false;
      }
    }

    ca.pop();
    cb.pop();
    return true;
  }
}
export function shouldRender(comp, nextProps, nextState) {
  var props = comp.props,
      state = comp.state;
  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);
}
export function toIdSchema(schema, id, rootSchema) {
  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "root";
  var idSchema = {
    $id: id || idPrefix
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);
  }

  if ("items" in schema && !schema.items.$ref) {
    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);
  }

  if (schema.type !== "object") {
    return idSchema;
  }

  for (var name in schema.properties || {}) {
    var field = schema.properties[name];
    var fieldId = idSchema.$id + "_" + name;
    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an
    // array item has just been added, but not populated with data yet
    (formData || {})[name], idPrefix);
  }

  return idSchema;
}
export function toPathSchema(schema) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;
  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var pathSchema = {
    $name: name.replace(/^\./, "")
  };

  if ("$ref" in schema || "dependencies" in schema || "allOf" in schema) {
    var _schema = retrieveSchema(schema, rootSchema, formData);

    return toPathSchema(_schema, name, rootSchema, formData);
  }

  if (schema.hasOwnProperty("additionalProperties")) {
    pathSchema.__rjsf_additionalProperties = true;
  }

  if (schema.hasOwnProperty("items") && Array.isArray(formData)) {
    formData.forEach(function (element, i) {
      pathSchema[i] = toPathSchema(schema.items, "".concat(name, ".").concat(i), rootSchema, element);
    });
  } else if (schema.hasOwnProperty("properties")) {
    for (var property in schema.properties) {
      pathSchema[property] = toPathSchema(schema.properties[property], "".concat(name, ".").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an
      // array item has just been added, but not populated with data yet
      (formData || {})[property]);
    }
  }

  return pathSchema;
}
export function parseDateString(dateString) {
  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (!dateString) {
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: includeTime ? -1 : 0,
      minute: includeTime ? -1 : 0,
      second: includeTime ? -1 : 0
    };
  }

  var date = new Date(dateString);

  if (Number.isNaN(date.getTime())) {
    throw new Error("Unable to parse date " + dateString);
  }

  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    // oh you, javascript.
    day: date.getUTCDate(),
    hour: includeTime ? date.getUTCHours() : 0,
    minute: includeTime ? date.getUTCMinutes() : 0,
    second: includeTime ? date.getUTCSeconds() : 0
  };
}
export function toDateString(_ref2) {
  var year = _ref2.year,
      month = _ref2.month,
      day = _ref2.day,
      _ref2$hour = _ref2.hour,
      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,
      _ref2$minute = _ref2.minute,
      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,
      _ref2$second = _ref2.second,
      second = _ref2$second === void 0 ? 0 : _ref2$second;
  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);
  var datetime = new Date(utcTime).toJSON();
  return time ? datetime : datetime.slice(0, 10);
}
export function utcToLocal(jsonDate) {
  if (!jsonDate) {
    return "";
  } // required format of `"yyyy-MM-ddThh:mm" followed by optional ":ss" or ":ss.SSS"
  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)
  // > should be a _valid local date and time string_ (not GMT)
  // Note - date constructor passed local ISO-8601 does not correctly
  // change time to UTC in node pre-8


  var date = new Date(jsonDate);
  var yyyy = pad(date.getFullYear(), 4);
  var MM = pad(date.getMonth() + 1, 2);
  var dd = pad(date.getDate(), 2);
  var hh = pad(date.getHours(), 2);
  var mm = pad(date.getMinutes(), 2);
  var ss = pad(date.getSeconds(), 2);
  var SSS = pad(date.getMilliseconds(), 3);
  return "".concat(yyyy, "-").concat(MM, "-").concat(dd, "T").concat(hh, ":").concat(mm, ":").concat(ss, ".").concat(SSS);
}
export function localToUTC(dateString) {
  if (dateString) {
    return new Date(dateString).toJSON();
  }
}
export function pad(num, size) {
  var s = String(num);

  while (s.length < size) {
    s = "0" + s;
  }

  return s;
}
export function dataURItoBlob(dataURI) {
  // Split metadata from data
  var splitted = dataURI.split(","); // Split params

  var params = splitted[0].split(";"); // Get mime-type from params

  var type = params[0].replace("data:", ""); // Filter the name property from params

  var properties = params.filter(function (param) {
    return param.split("=")[0] === "name";
  }); // Look for the name and use unknown if no name property.

  var name;

  if (properties.length !== 1) {
    name = "unknown";
  } else {
    // Because we filtered out the other property,
    // we only have the name case here.
    name = properties[0].split("=")[1];
  } // Built the Uint8Array Blob parameter from the base64 string.


  var binary = atob(splitted[1]);
  var array = [];

  for (var _i = 0; _i < binary.length; _i++) {
    array.push(binary.charCodeAt(_i));
  } // Create the blob object


  var blob = new window.Blob([new Uint8Array(array)], {
    type: type
  });
  return {
    blob: blob,
    name: name
  };
}
export function rangeSpec(schema) {
  var spec = {};

  if (schema.multipleOf) {
    spec.step = schema.multipleOf;
  }

  if (schema.minimum || schema.minimum === 0) {
    spec.min = schema.minimum;
  }

  if (schema.maximum || schema.maximum === 0) {
    spec.max = schema.maximum;
  }

  return spec;
}
export function getMatchingOption(formData, options, rootSchema) {
  for (var _i2 = 0; _i2 < options.length; _i2++) {
    var option = options[_i2]; // If the schema describes an object then we need to add slightly more
    // strict matching to the schema, because unless the schema uses the
    // "requires" keyword, an object will match the schema as long as it
    // doesn't have matching keys with a conflicting type. To do this we use an
    // "anyOf" with an array of requires. This augmentation expresses that the
    // schema should match if any of the keys in the schema are present on the
    // object and pass validation.

    if (option.properties) {
      // Create an "anyOf" schema that requires at least one of the keys in the
      // "properties" object
      var requiresAnyOf = {
        anyOf: Object.keys(option.properties).map(function (key) {
          return {
            required: [key]
          };
        })
      };
      var augmentedSchema = void 0; // If the "anyOf" keyword already exists, wrap the augmentation in an "allOf"

      if (option.anyOf) {
        // Create a shallow clone of the option
        var shallowClone = _extends({}, option);

        if (!shallowClone.allOf) {
          shallowClone.allOf = [];
        } else {
          // If "allOf" already exists, shallow clone the array
          shallowClone.allOf = shallowClone.allOf.slice();
        }

        shallowClone.allOf.push(requiresAnyOf);
        augmentedSchema = shallowClone;
      } else {
        augmentedSchema = Object.assign({}, option, requiresAnyOf);
      } // Remove the "required" field as it's likely that not all fields have
      // been filled in yet, which will mean that the schema is not valid


      delete augmentedSchema.required;

      if (isValid(augmentedSchema, formData, rootSchema)) {
        return _i2;
      }
    } else if (isValid(option, formData, rootSchema)) {
      return _i2;
    }
  }

  return 0;
} // Check to see if a schema specifies that a value must be true

export function schemaRequiresTrueValue(schema) {
  // Check if const is a truthy value
  if (schema["const"]) {
    return true;
  } // Check if an enum has a single value of true


  if (schema["enum"] && schema["enum"].length === 1 && schema["enum"][0] === true) {
    return true;
  } // If anyOf has a single value, evaluate the subschema


  if (schema.anyOf && schema.anyOf.length === 1) {
    return schemaRequiresTrueValue(schema.anyOf[0]);
  } // If oneOf has a single value, evaluate the subschema


  if (schema.oneOf && schema.oneOf.length === 1) {
    return schemaRequiresTrueValue(schema.oneOf[0]);
  } // Evaluate each subschema in allOf, to see if one of them requires a true
  // value


  if (schema.allOf) {
    return schema.allOf.some(schemaRequiresTrueValue);
  }

  return false;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0SXMiLCJtZXJnZUFsbE9mIiwiZmlsbCIsInVuaW9uIiwianNvbnBvaW50ZXIiLCJmaWVsZHMiLCJ3aWRnZXRzIiwidmFsaWRhdGVGb3JtRGF0YSIsImlzVmFsaWQiLCJBRERJVElPTkFMX1BST1BFUlRZX0ZMQUciLCJ3aWRnZXRNYXAiLCJjaGVja2JveCIsInJhZGlvIiwic2VsZWN0IiwiaGlkZGVuIiwic3RyaW5nIiwidGV4dCIsInBhc3N3b3JkIiwiZW1haWwiLCJob3N0bmFtZSIsImlwdjQiLCJpcHY2IiwidXJpIiwidGV4dGFyZWEiLCJkYXRlIiwiZGF0ZXRpbWUiLCJjb2xvciIsImZpbGUiLCJudW1iZXIiLCJ1cGRvd24iLCJyYW5nZSIsImludGVnZXIiLCJhcnJheSIsImNoZWNrYm94ZXMiLCJmaWxlcyIsImNhbkV4cGFuZCIsInNjaGVtYSIsInVpU2NoZW1hIiwiZm9ybURhdGEiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImdldFVpT3B0aW9ucyIsImV4cGFuZGFibGUiLCJtYXhQcm9wZXJ0aWVzIiwidW5kZWZpbmVkIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImdldERlZmF1bHRSZWdpc3RyeSIsImRlZmluaXRpb25zIiwicm9vdFNjaGVtYSIsImZvcm1Db250ZXh0IiwiZ2V0U2NoZW1hVHlwZSIsInR5cGUiLCJndWVzc1R5cGUiLCJwcm9wZXJ0aWVzIiwiQXJyYXkiLCJpbmNsdWRlcyIsImZpbmQiLCJnZXRXaWRnZXQiLCJ3aWRnZXQiLCJyZWdpc3RlcmVkV2lkZ2V0cyIsIm1lcmdlT3B0aW9ucyIsIldpZGdldCIsIk1lcmdlZFdpZGdldCIsImRlZmF1bHRPcHRpb25zIiwiZGVmYXVsdFByb3BzIiwib3B0aW9ucyIsInByb3BzIiwiaXNGb3J3YXJkUmVmIiwiY3JlYXRlRWxlbWVudCIsImlzTWVtbyIsIkVycm9yIiwiaGFzT3duUHJvcGVydHkiLCJyZWdpc3RlcmVkV2lkZ2V0IiwiaGFzV2lkZ2V0IiwiZSIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiY29tcHV0ZURlZmF1bHRzIiwiX3NjaGVtYSIsInBhcmVudERlZmF1bHRzIiwicmF3Rm9ybURhdGEiLCJpbmNsdWRlVW5kZWZpbmVkVmFsdWVzIiwiaXNPYmplY3QiLCJkZWZhdWx0cyIsIm1lcmdlT2JqZWN0cyIsInJlZlNjaGVtYSIsImZpbmRTY2hlbWFEZWZpbml0aW9uIiwiJHJlZiIsInJlc29sdmVkU2NoZW1hIiwicmVzb2x2ZURlcGVuZGVuY2llcyIsImlzRml4ZWRJdGVtcyIsIml0ZW1zIiwibWFwIiwiaXRlbVNjaGVtYSIsImlkeCIsImlzQXJyYXkiLCJvbmVPZiIsImdldE1hdGNoaW5nT3B0aW9uIiwiYW55T2YiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJjb21wdXRlZERlZmF1bHQiLCJpdGVtIiwiYWRkaXRpb25hbEl0ZW1zIiwibWluSXRlbXMiLCJpc011bHRpU2VsZWN0IiwiZGVmYXVsdHNMZW5ndGgiLCJkZWZhdWx0RW50cmllcyIsImZpbGxlclNjaGVtYSIsImZpbGxlckVudHJpZXMiLCJjb25jYXQiLCJnZXREZWZhdWx0Rm9ybVN0YXRlIiwicmV0cmlldmVTY2hlbWEiLCJtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhIiwidmFsdWUiLCJhc3NpZ24iLCJmaWx0ZXIiLCJpbmRleE9mIiwiY29uc29sZSIsIndhcm4iLCJjb21wb25lbnQiLCJzdWJzdHJpbmciLCJnZXREaXNwbGF5TGFiZWwiLCJ1aU9wdGlvbnMiLCJsYWJlbCIsImRpc3BsYXlMYWJlbCIsInNjaGVtYVR5cGUiLCJpc0ZpbGVzQXJyYXkiLCJ0aGluZyIsIkZpbGUiLCJvYmoxIiwib2JqMiIsImNvbmNhdEFycmF5cyIsImxlZnQiLCJyaWdodCIsImFzTnVtYmVyIiwidGVzdCIsIm4iLCJOdW1iZXIiLCJ2YWxpZCIsImlzTmFOIiwib3JkZXJQcm9wZXJ0aWVzIiwib3JkZXIiLCJhcnJheVRvSGFzaCIsImFyciIsInByZXYiLCJjdXJyIiwiZXJyb3JQcm9wTGlzdCIsImpvaW4iLCJwcm9wZXJ0eUhhc2giLCJvcmRlckZpbHRlcmVkIiwicHJvcCIsIm9yZGVySGFzaCIsInJlc3QiLCJyZXN0SW5kZXgiLCJsYXN0SW5kZXhPZiIsImNvbXBsZXRlIiwic3BsaWNlIiwiaXNDb25zdGFudCIsInRvQ29uc3RhbnQiLCJpc1NlbGVjdCIsImFsdFNjaGVtYXMiLCJldmVyeSIsInVuaXF1ZUl0ZW1zIiwiaXRlbXNTY2hlbWEiLCJmb3JtYXQiLCJhbGxvd0FkZGl0aW9uYWxJdGVtcyIsIm9wdGlvbnNMaXN0IiwiaSIsImVudW1OYW1lcyIsIlN0cmluZyIsInRpdGxlIiwib3JpZ1JlZiIsImRlY29kZVVSSUNvbXBvbmVudCIsImN1cnJlbnQiLCJnZXQiLCJzdHViRXhpc3RpbmdBZGRpdGlvbmFsUHJvcGVydGllcyIsImZvckVhY2giLCJyZXNvbHZlU2NoZW1hIiwicmVzb2x2ZVJlZmVyZW5jZSIsImFsbE9mIiwiYWxsT2ZTdWJzY2hlbWEiLCIkcmVmU2NoZW1hIiwibG9jYWxTY2hlbWEiLCJyZXNvbHZlZFNjaGVtYVdpdGhvdXRBbGxPZiIsImhhc0FkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiZGVwZW5kZW5jaWVzIiwicHJvY2Vzc0RlcGVuZGVuY2llcyIsImRlcGVuZGVuY3lLZXkiLCJkZXBlbmRlbmN5VmFsdWUiLCJyZW1haW5pbmdEZXBlbmRlbmNpZXMiLCJ3aXRoRGVwZW5kZW50UHJvcGVydGllcyIsIndpdGhEZXBlbmRlbnRTY2hlbWEiLCJhZGRpdGlvbmFsbHlSZXF1aXJlZCIsInJlcXVpcmVkIiwiZnJvbSIsIlNldCIsImRlcGVuZGVudFNjaGVtYSIsIm1lcmdlU2NoZW1hcyIsInJlc29sdmVkT25lT2YiLCJzdWJzY2hlbWEiLCJ3aXRoRXhhY3RseU9uZVN1YnNjaGVtYSIsInZhbGlkU3Vic2NoZW1hcyIsImNvbmRpdGlvblByb3BlcnR5U2NoZW1hIiwiY29uZGl0aW9uU2NoZW1hIiwiZXJyb3JzIiwiZGVwZW5kZW50U3Vic2NoZW1hIiwiaXNBcmd1bWVudHMiLCJvYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJkZWVwRXF1YWxzIiwiYSIsImIiLCJjYSIsImNiIiwiRGF0ZSIsImdldFRpbWUiLCJSZWdFeHAiLCJzb3VyY2UiLCJnbG9iYWwiLCJtdWx0aWxpbmUiLCJsYXN0SW5kZXgiLCJpZ25vcmVDYXNlIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsImthIiwia2IiLCJjYWwiLCJwdXNoIiwic29ydCIsImoiLCJrIiwicG9wIiwic2hvdWxkUmVuZGVyIiwiY29tcCIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsInN0YXRlIiwidG9JZFNjaGVtYSIsImlkIiwiaWRQcmVmaXgiLCJpZFNjaGVtYSIsIiRpZCIsIm5hbWUiLCJmaWVsZCIsImZpZWxkSWQiLCJ0b1BhdGhTY2hlbWEiLCJwYXRoU2NoZW1hIiwiJG5hbWUiLCJyZXBsYWNlIiwiX19yanNmX2FkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiZWxlbWVudCIsInByb3BlcnR5IiwicGFyc2VEYXRlU3RyaW5nIiwiZGF0ZVN0cmluZyIsImluY2x1ZGVUaW1lIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInNlY29uZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsInRvRGF0ZVN0cmluZyIsInRpbWUiLCJ1dGNUaW1lIiwiVVRDIiwidG9KU09OIiwidXRjVG9Mb2NhbCIsImpzb25EYXRlIiwieXl5eSIsInBhZCIsImdldEZ1bGxZZWFyIiwiTU0iLCJnZXRNb250aCIsImRkIiwiZ2V0RGF0ZSIsImhoIiwiZ2V0SG91cnMiLCJtbSIsImdldE1pbnV0ZXMiLCJzcyIsImdldFNlY29uZHMiLCJTU1MiLCJnZXRNaWxsaXNlY29uZHMiLCJsb2NhbFRvVVRDIiwibnVtIiwic2l6ZSIsInMiLCJkYXRhVVJJdG9CbG9iIiwiZGF0YVVSSSIsInNwbGl0dGVkIiwic3BsaXQiLCJwYXJhbXMiLCJwYXJhbSIsImJpbmFyeSIsImF0b2IiLCJjaGFyQ29kZUF0IiwiYmxvYiIsIndpbmRvdyIsIkJsb2IiLCJVaW50OEFycmF5IiwicmFuZ2VTcGVjIiwic3BlYyIsIm11bHRpcGxlT2YiLCJzdGVwIiwibWluaW11bSIsIm1pbiIsIm1heGltdW0iLCJtYXgiLCJvcHRpb24iLCJyZXF1aXJlc0FueU9mIiwiYXVnbWVudGVkU2NoZW1hIiwic2hhbGxvd0Nsb25lIiwic2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUiLCJzb21lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLE1BQWtCLE9BQWxCO0FBQ0EsT0FBTyxLQUFLQyxPQUFaLE1BQXlCLFVBQXpCO0FBQ0EsT0FBT0MsVUFBUCxNQUF1Qix5QkFBdkI7QUFDQSxPQUFPQyxJQUFQLE1BQWlCLGtDQUFqQjtBQUNBLE9BQU9DLEtBQVAsTUFBa0IsY0FBbEI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLGFBQXhCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixxQkFBbkI7QUFDQSxPQUFPQyxPQUFQLE1BQW9CLHNCQUFwQjtBQUNBLE9BQU9DLGdCQUFQLElBQTJCQyxPQUEzQixRQUEwQyxZQUExQztBQUVBLE9BQU8sSUFBTUMsd0JBQXdCLEdBQUcsdUJBQWpDO0FBRVAsSUFBTUMsU0FBUyxHQUFHO0FBQ2hCLGFBQVM7QUFDUEMsSUFBQUEsUUFBUSxFQUFFLGdCQURIO0FBRVBDLElBQUFBLEtBQUssRUFBRSxhQUZBO0FBR1BDLElBQUFBLE1BQU0sRUFBRSxjQUhEO0FBSVBDLElBQUFBLE1BQU0sRUFBRTtBQUpELEdBRE87QUFPaEJDLEVBQUFBLE1BQU0sRUFBRTtBQUNOQyxJQUFBQSxJQUFJLEVBQUUsWUFEQTtBQUVOQyxJQUFBQSxRQUFRLEVBQUUsZ0JBRko7QUFHTkMsSUFBQUEsS0FBSyxFQUFFLGFBSEQ7QUFJTkMsSUFBQUEsUUFBUSxFQUFFLFlBSko7QUFLTkMsSUFBQUEsSUFBSSxFQUFFLFlB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QztBQUM3QyxXQUFPcVIsdUJBQXVCLENBQUMvUixNQUFNLENBQUMrRCxLQUFQLENBQWEsQ0FBYixDQUFELENBQTlCO0FBQ0QsR0FkNkMsQ0FnQjlDOzs7QUFDQSxNQUFJL0QsTUFBTSxDQUFDNkQsS0FBUCxJQUFnQjdELE1BQU0sQ0FBQzZELEtBQVAsQ0FBYW5ELE1BQWIsS0FBd0IsQ0FBNUMsRUFBK0M7QUFDN0MsV0FBT3FSLHVCQUF1QixDQUFDL1IsTUFBTSxDQUFDNkQsS0FBUCxDQUFhLENBQWIsQ0FBRCxDQUE5QjtBQUNELEdBbkI2QyxDQXFCOUM7QUFDQTs7O0FBQ0EsTUFBSTdELE1BQU0sQ0FBQ2tKLEtBQVgsRUFBa0I7QUFDaEIsV0FBT2xKLE1BQU0sQ0FBQ2tKLEtBQVAsQ0FBYThJLElBQWIsQ0FBa0JELHVCQUFsQixDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxLQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBSZWFjdElzIGZyb20gXCJyZWFjdC1pc1wiO1xuaW1wb3J0IG1lcmdlQWxsT2YgZnJvbSBcImpzb24tc2NoZW1hLW1lcmdlLWFsbG9mXCI7XG5pbXBvcnQgZmlsbCBmcm9tIFwiY29yZS1qcy1wdXJlL2ZlYXR1cmVzL2FycmF5L2ZpbGxcIjtcbmltcG9ydCB1bmlvbiBmcm9tIFwibG9kYXNoL3VuaW9uXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb25wb2ludGVyXCI7XG5pbXBvcnQgZmllbGRzIGZyb20gXCIuL2NvbXBvbmVudHMvZmllbGRzXCI7XG5pbXBvcnQgd2lkZ2V0cyBmcm9tIFwiLi9jb21wb25lbnRzL3dpZGdldHNcIjtcbmltcG9ydCB2YWxpZGF0ZUZvcm1EYXRhLCB7IGlzVmFsaWQgfSBmcm9tIFwiLi92YWxpZGF0ZVwiO1xuXG5leHBvcnQgY29uc3QgQURESVRJT05BTF9QUk9QRVJUWV9GTEFHID0gXCJfX2FkZGl0aW9uYWxfcHJvcGVydHlcIjtcblxuY29uc3Qgd2lkZ2V0TWFwID0ge1xuICBib29sZWFuOiB7XG4gICAgY2hlY2tib3g6IFwiQ2hlY2tib3hXaWRnZXRcIixcbiAgICByYWRpbzogXCJSYWRpb1dpZGdldFwiLFxuICAgIHNlbGVjdDogXCJTZWxlY3RXaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gIH0sXG4gIHN0cmluZzoge1xuICAgIHRleHQ6IFwiVGV4dFdpZGdldFwiLFxuICAgIHBhc3N3b3JkOiBcIlBhc3N3b3JkV2lkZ2V0XCIsXG4gICAgZW1haWw6IFwiRW1haWxXaWRnZXRcIixcbiAgICBob3N0bmFtZTogXCJUZXh0V2lkZ2V0XCIsXG4gICAgaXB2NDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgaXB2NjogXCJUZXh0V2lkZ2V0XCIsXG4gICAgdXJpOiBcIlVSTFdpZGdldFwiLFxuICAgIFwiZGF0YS11cmxcIjogXCJGaWxlV2lkZ2V0XCIsXG4gICAgcmFkaW86IFwiUmFkaW9XaWRnZXRcIixcbiAgICBzZWxlY3Q6IFwiU2VsZWN0V2lkZ2V0XCIsXG4gICAgdGV4dGFyZWE6IFwiVGV4dGFyZWFXaWRnZXRcIixcbiAgICBoaWRkZW46IFwiSGlkZGVuV2lkZ2V0XCIsXG4gICAgZGF0ZTogXCJEYXRlV2lkZ2V0XCIsXG4gICAgZGF0ZXRpbWU6IFwiRGF0ZVRpbWVXaWRnZXRcIixcbiAgICBcImRhdGUtdGltZVwiOiBcIkRhdGVUaW1lV2lkZ2V0XCIsXG4gICAgXCJhbHQtZGF0ZVwiOiBcIkFsdERhdGVXaWRnZXRcIixcbiAgICBcImFsdC1kYXRldGltZVwiOiBcIkFsdERhdGVUaW1lV2lkZ2V0XCIsXG4gICAgY29sb3I6IFwiQ29sb3JXaWRnZXRcIixcbiAgICBmaWxlOiBcIkZpbGVXaWRnZXRcIixcbiAgfSxcbiAgbnVtYmVyOiB7XG4gICAgdGV4dDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgc2VsZWN0OiBcIlNlbGVjdFdpZGdldFwiLFxuICAgIHVwZG93bjogXCJVcERvd25XaWRnZXRcIixcbiAgICByYW5nZTogXCJSYW5nZVdpZGdldFwiLFxuICAgIHJhZGlvOiBcIlJhZGlvV2lkZ2V0XCIsXG4gICAgaGlkZGVuOiBcIkhpZGRlbldpZGdldFwiLFxuICB9LFxuICBpbnRlZ2VyOiB7XG4gICAgdGV4dDogXCJUZXh0V2lkZ2V0XCIsXG4gICAgc2VsZWN0OiBcIlNlbGVjdFdpZGdldFwiLFxuICAgIHVwZG93bjogXCJVcERvd25XaWRnZXRcIixcbiAgICByYW5nZTogXCJSYW5nZVdpZGdldFwiLFxuICAgIHJhZGlvOiBcIlJhZGlvV2lkZ2V0XCIsXG4gICAgaGlkZGVuOiBcIkhpZGRlbldpZGdldFwiLFxuICB9LFxuICBhcnJheToge1xuICAgIHNlbGVjdDogXCJTZWxlY3RXaWRnZXRcIixcbiAgICBjaGVja2JveGVzOiBcIkNoZWNrYm94ZXNXaWRnZXRcIixcbiAgICBmaWxlczogXCJGaWxlV2lkZ2V0XCIsXG4gICAgaGlkZGVuOiBcIkhpZGRlbldpZGdldFwiLFxuICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbkV4cGFuZChzY2hlbWEsIHVpU2NoZW1hLCBmb3JtRGF0YSkge1xuICBpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7IGV4cGFuZGFibGUgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSk7XG4gIGlmIChleHBhbmRhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBleHBhbmRhYmxlO1xuICB9XG4gIC8vIGlmIHVpOm9wdGlvbnMuZXhwYW5kYWJsZSB3YXMgbm90IGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLCB3ZSBjYW4gYWRkXG4gIC8vIGFub3RoZXIgcHJvcGVydHkgaWYgd2UgaGF2ZSBub3QgZXhjZWVkZWQgbWF4UHJvcGVydGllcyB5ZXRcbiAgaWYgKHNjaGVtYS5tYXhQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybURhdGEpLmxlbmd0aCA8IHNjaGVtYS5tYXhQcm9wZXJ0aWVzO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFJlZ2lzdHJ5KCkge1xuICByZXR1cm4ge1xuICAgIGZpZWxkcyxcbiAgICB3aWRnZXRzLFxuICAgIGRlZmluaXRpb25zOiB7fSxcbiAgICByb290U2NoZW1hOiB7fSxcbiAgICBmb3JtQ29udGV4dDoge30sXG4gIH07XG59XG5cbi8qIEdldHMgdGhlIHR5cGUgb2YgYSBnaXZlbiBzY2hlbWEuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZShzY2hlbWEpIHtcbiAgbGV0IHsgdHlwZSB9ID0gc2NoZW1hO1xuXG4gIGlmICghdHlwZSAmJiBzY2hlbWEuY29uc3QpIHtcbiAgICByZXR1cm4gZ3Vlc3NUeXBlKHNjaGVtYS5jb25zdCk7XG4gIH1cblxuICBpZiAoIXR5cGUgJiYgc2NoZW1hLmVudW0pIHtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGlmICghdHlwZSAmJiAoc2NoZW1hLnByb3BlcnRpZXMgfHwgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSkge1xuICAgIHJldHVybiBcIm9iamVjdFwiO1xuICB9XG5cbiAgaWYgKHR5cGUgaW5zdGFuY2VvZiBBcnJheSAmJiB0eXBlLmxlbmd0aCA9PT0gMiAmJiB0eXBlLmluY2x1ZGVzKFwibnVsbFwiKSkge1xuICAgIHJldHVybiB0eXBlLmZpbmQodHlwZSA9PiB0eXBlICE9PSBcIm51bGxcIik7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdpZGdldChzY2hlbWEsIHdpZGdldCwgcmVnaXN0ZXJlZFdpZGdldHMgPSB7fSkge1xuICBjb25zdCB0eXBlID0gZ2V0U2NoZW1hVHlwZShzY2hlbWEpO1xuXG4gIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhXaWRnZXQpIHtcbiAgICAvLyBjYWNoZSByZXR1cm4gdmFsdWUgYXMgcHJvcGVydHkgb2Ygd2lkZ2V0IGZvciBwcm9wZXIgcmVhY3QgcmVjb25jaWxpYXRpb25cbiAgICBpZiAoIVdpZGdldC5NZXJnZWRXaWRnZXQpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID1cbiAgICAgICAgKFdpZGdldC5kZWZhdWx0UHJvcHMgJiYgV2lkZ2V0LmRlZmF1bHRQcm9wcy5vcHRpb25zKSB8fCB7fTtcbiAgICAgIFdpZGdldC5NZXJnZWRXaWRnZXQgPSAoeyBvcHRpb25zID0ge30sIC4uLnByb3BzIH0pID0+IChcbiAgICAgICAgPFdpZGdldCBvcHRpb25zPXt7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH19IHsuLi5wcm9wc30gLz5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBXaWRnZXQuTWVyZ2VkV2lkZ2V0O1xuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiB3aWRnZXQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIFJlYWN0SXMuaXNGb3J3YXJkUmVmKFJlYWN0LmNyZWF0ZUVsZW1lbnQod2lkZ2V0KSkgfHxcbiAgICBSZWFjdElzLmlzTWVtbyh3aWRnZXQpXG4gICkge1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMod2lkZ2V0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2lkZ2V0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB3aWRnZXQgZGVmaW5pdGlvbjogJHt0eXBlb2Ygd2lkZ2V0fWApO1xuICB9XG5cbiAgaWYgKHJlZ2lzdGVyZWRXaWRnZXRzLmhhc093blByb3BlcnR5KHdpZGdldCkpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkV2lkZ2V0ID0gcmVnaXN0ZXJlZFdpZGdldHNbd2lkZ2V0XTtcbiAgICByZXR1cm4gZ2V0V2lkZ2V0KHNjaGVtYSwgcmVnaXN0ZXJlZFdpZGdldCwgcmVnaXN0ZXJlZFdpZGdldHMpO1xuICB9XG5cbiAgaWYgKCF3aWRnZXRNYXAuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHdpZGdldCBmb3IgdHlwZSBcIiR7dHlwZX1cImApO1xuICB9XG5cbiAgaWYgKHdpZGdldE1hcFt0eXBlXS5oYXNPd25Qcm9wZXJ0eSh3aWRnZXQpKSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZFdpZGdldCA9IHJlZ2lzdGVyZWRXaWRnZXRzW3dpZGdldE1hcFt0eXBlXVt3aWRnZXRdXTtcbiAgICByZXR1cm4gZ2V0V2lkZ2V0KHNjaGVtYSwgcmVnaXN0ZXJlZFdpZGdldCwgcmVnaXN0ZXJlZFdpZGdldHMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBObyB3aWRnZXQgXCIke3dpZGdldH1cIiBmb3IgdHlwZSBcIiR7dHlwZX1cImApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzV2lkZ2V0KHNjaGVtYSwgd2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyA9IHt9KSB7XG4gIHRyeSB7XG4gICAgZ2V0V2lkZ2V0KHNjaGVtYSwgd2lkZ2V0LCByZWdpc3RlcmVkV2lkZ2V0cyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoXG4gICAgICBlLm1lc3NhZ2UgJiZcbiAgICAgIChlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIk5vIHdpZGdldFwiKSB8fFxuICAgICAgICBlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlVuc3VwcG9ydGVkIHdpZGdldFwiKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVmYXVsdHMoXG4gIF9zY2hlbWEsXG4gIHBhcmVudERlZmF1bHRzLFxuICByb290U2NoZW1hLFxuICByYXdGb3JtRGF0YSA9IHt9LFxuICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzID0gZmFsc2Vcbikge1xuICBsZXQgc2NoZW1hID0gaXNPYmplY3QoX3NjaGVtYSkgPyBfc2NoZW1hIDoge307XG4gIGNvbnN0IGZvcm1EYXRhID0gaXNPYmplY3QocmF3Rm9ybURhdGEpID8gcmF3Rm9ybURhdGEgOiB7fTtcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdHMgcmVjdXJzaXZlbHk6IGdpdmUgaGlnaGVzdCBwcmlvcml0eSB0byBkZWVwZXN0IG5vZGVzLlxuICBsZXQgZGVmYXVsdHMgPSBwYXJlbnREZWZhdWx0cztcbiAgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSAmJiBpc09iamVjdChzY2hlbWEuZGVmYXVsdCkpIHtcbiAgICAvLyBGb3Igb2JqZWN0IGRlZmF1bHRzLCBvbmx5IG92ZXJyaWRlIHBhcmVudCBkZWZhdWx0cyB0aGF0IGFyZSBkZWZpbmVkIGluXG4gICAgLy8gc2NoZW1hLmRlZmF1bHQuXG4gICAgZGVmYXVsdHMgPSBtZXJnZU9iamVjdHMoZGVmYXVsdHMsIHNjaGVtYS5kZWZhdWx0KTtcbiAgfSBlbHNlIGlmIChcImRlZmF1bHRcIiBpbiBzY2hlbWEpIHtcbiAgICAvLyBVc2Ugc2NoZW1hIGRlZmF1bHRzIGZvciB0aGlzIG5vZGUuXG4gICAgZGVmYXVsdHMgPSBzY2hlbWEuZGVmYXVsdDtcbiAgfSBlbHNlIGlmIChcIiRyZWZcIiBpbiBzY2hlbWEpIHtcbiAgICAvLyBVc2UgcmVmZXJlbmNlZCBzY2hlbWEgZGVmYXVsdHMgZm9yIHRoaXMgbm9kZS5cbiAgICBjb25zdCByZWZTY2hlbWEgPSBmaW5kU2NoZW1hRGVmaW5pdGlvbihzY2hlbWEuJHJlZiwgcm9vdFNjaGVtYSk7XG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0cyhcbiAgICAgIHJlZlNjaGVtYSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgcm9vdFNjaGVtYSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlc1xuICAgICk7XG4gIH0gZWxzZSBpZiAoXCJkZXBlbmRlbmNpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IHJlc29sdmVEZXBlbmRlbmNpZXMoc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0cyhcbiAgICAgIHJlc29sdmVkU2NoZW1hLFxuICAgICAgZGVmYXVsdHMsXG4gICAgICByb290U2NoZW1hLFxuICAgICAgZm9ybURhdGEsXG4gICAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc0ZpeGVkSXRlbXMoc2NoZW1hKSkge1xuICAgIGRlZmF1bHRzID0gc2NoZW1hLml0ZW1zLm1hcCgoaXRlbVNjaGVtYSwgaWR4KSA9PlxuICAgICAgY29tcHV0ZURlZmF1bHRzKFxuICAgICAgICBpdGVtU2NoZW1hLFxuICAgICAgICBBcnJheS5pc0FycmF5KHBhcmVudERlZmF1bHRzKSA/IHBhcmVudERlZmF1bHRzW2lkeF0gOiB1bmRlZmluZWQsXG4gICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBpbmNsdWRlVW5kZWZpbmVkVmFsdWVzXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIGlmIChcIm9uZU9mXCIgaW4gc2NoZW1hKSB7XG4gICAgc2NoZW1hID1cbiAgICAgIHNjaGVtYS5vbmVPZltnZXRNYXRjaGluZ09wdGlvbih1bmRlZmluZWQsIHNjaGVtYS5vbmVPZiwgcm9vdFNjaGVtYSldO1xuICB9IGVsc2UgaWYgKFwiYW55T2ZcIiBpbiBzY2hlbWEpIHtcbiAgICBzY2hlbWEgPVxuICAgICAgc2NoZW1hLmFueU9mW2dldE1hdGNoaW5nT3B0aW9uKHVuZGVmaW5lZCwgc2NoZW1hLmFueU9mLCByb290U2NoZW1hKV07XG4gIH1cblxuICAvLyBOb3QgZGVmYXVsdHMgZGVmaW5lZCBmb3IgdGhpcyBub2RlLCBmYWxsYmFjayB0byBnZW5lcmljIHR5cGVkIG9uZXMuXG4gIGlmICh0eXBlb2YgZGVmYXVsdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkZWZhdWx0cyA9IHNjaGVtYS5kZWZhdWx0O1xuICB9XG5cbiAgc3dpdGNoIChnZXRTY2hlbWFUeXBlKHNjaGVtYSkpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHJlY3VyIGZvciBvYmplY3Qgc2NoZW1hIGlubmVyIGRlZmF1bHQgdmFsdWVzLlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyB8fCB7fSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0cyBmb3IgdGhpcyBub2RlLCB3aXRoIHRoZSBwYXJlbnQgZGVmYXVsdHMgd2UgbWlnaHRcbiAgICAgICAgLy8gaGF2ZSBmcm9tIGEgcHJldmlvdXMgcnVuOiBkZWZhdWx0c1trZXldLlxuICAgICAgICBsZXQgY29tcHV0ZWREZWZhdWx0ID0gY29tcHV0ZURlZmF1bHRzKFxuICAgICAgICAgIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgICAgKGRlZmF1bHRzIHx8IHt9KVtrZXldLFxuICAgICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgICAgKGZvcm1EYXRhIHx8IHt9KVtrZXldLFxuICAgICAgICAgIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluY2x1ZGVVbmRlZmluZWRWYWx1ZXMgfHwgY29tcHV0ZWREZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhY2Nba2V5XSA9IGNvbXB1dGVkRGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuXG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAvLyBJbmplY3QgZGVmYXVsdHMgaW50byBleGlzdGluZyBhcnJheSBkZWZhdWx0c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XG4gICAgICAgIGRlZmF1bHRzID0gZGVmYXVsdHMubWFwKChpdGVtLCBpZHgpID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRzKFxuICAgICAgICAgICAgc2NoZW1hLml0ZW1zW2lkeF0gfHwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyB8fCB7fSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICByb290U2NoZW1hXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlZXBseSBpbmplY3QgZGVmYXVsdHMgaW50byBhbHJlYWR5IGV4aXN0aW5nIGZvcm0gZGF0YVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3Rm9ybURhdGEpKSB7XG4gICAgICAgIGRlZmF1bHRzID0gcmF3Rm9ybURhdGEubWFwKChpdGVtLCBpZHgpID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRzKFxuICAgICAgICAgICAgc2NoZW1hLml0ZW1zLFxuICAgICAgICAgICAgKGRlZmF1bHRzIHx8IHt9KVtpZHhdLFxuICAgICAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzY2hlbWEubWluSXRlbXMpIHtcbiAgICAgICAgaWYgKCFpc011bHRpU2VsZWN0KHNjaGVtYSwgcm9vdFNjaGVtYSkpIHtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0c0xlbmd0aCA9IGRlZmF1bHRzID8gZGVmYXVsdHMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAoc2NoZW1hLm1pbkl0ZW1zID4gZGVmYXVsdHNMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFbnRyaWVzID0gZGVmYXVsdHMgfHwgW107XG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSB0aGUgYXJyYXkgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICAgICAgICAgIGNvbnN0IGZpbGxlclNjaGVtYSA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKVxuICAgICAgICAgICAgICA/IHNjaGVtYS5hZGRpdGlvbmFsSXRlbXNcbiAgICAgICAgICAgICAgOiBzY2hlbWEuaXRlbXM7XG4gICAgICAgICAgICBjb25zdCBmaWxsZXJFbnRyaWVzID0gZmlsbChcbiAgICAgICAgICAgICAgbmV3IEFycmF5KHNjaGVtYS5taW5JdGVtcyAtIGRlZmF1bHRzTGVuZ3RoKSxcbiAgICAgICAgICAgICAgY29tcHV0ZURlZmF1bHRzKGZpbGxlclNjaGVtYSwgZmlsbGVyU2NoZW1hLmRlZmF1bHRzLCByb290U2NoZW1hKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHRoZW4gZmlsbCB1cCB0aGUgcmVzdCB3aXRoIGVpdGhlciB0aGUgaXRlbSBkZWZhdWx0IG9yIGVtcHR5LCB1cCB0byBtaW5JdGVtc1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEVudHJpZXMuY29uY2F0KGZpbGxlckVudHJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdHMgPyBkZWZhdWx0cyA6IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZvcm1TdGF0ZShcbiAgX3NjaGVtYSxcbiAgZm9ybURhdGEsXG4gIHJvb3RTY2hlbWEgPSB7fSxcbiAgaW5jbHVkZVVuZGVmaW5lZFZhbHVlcyA9IGZhbHNlXG4pIHtcbiAgaWYgKCFpc09iamVjdChfc2NoZW1hKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2NoZW1hOiBcIiArIF9zY2hlbWEpO1xuICB9XG4gIGNvbnN0IHNjaGVtYSA9IHJldHJpZXZlU2NoZW1hKF9zY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgY29uc3QgZGVmYXVsdHMgPSBjb21wdXRlRGVmYXVsdHMoXG4gICAgc2NoZW1hLFxuICAgIF9zY2hlbWEuZGVmYXVsdCxcbiAgICByb290U2NoZW1hLFxuICAgIGZvcm1EYXRhLFxuICAgIGluY2x1ZGVVbmRlZmluZWRWYWx1ZXNcbiAgKTtcbiAgaWYgKHR5cGVvZiBmb3JtRGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIE5vIGZvcm0gZGF0YT8gVXNlIHNjaGVtYSBkZWZhdWx0cy5cbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGZvcm1EYXRhKSB8fCBBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgIHJldHVybiBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhKGRlZmF1bHRzLCBmb3JtRGF0YSk7XG4gIH1cbiAgaWYgKGZvcm1EYXRhID09PSAwIHx8IGZvcm1EYXRhID09PSBmYWxzZSB8fCBmb3JtRGF0YSA9PT0gXCJcIikge1xuICAgIHJldHVybiBmb3JtRGF0YTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGEgfHwgZGVmYXVsdHM7XG59XG5cbi8qKlxuICogV2hlbiBtZXJnaW5nIGRlZmF1bHRzIGFuZCBmb3JtIGRhdGEsIHdlIHdhbnQgdG8gbWVyZ2UgaW4gdGhpcyBzcGVjaWZpYyB3YXk6XG4gKiAtIG9iamVjdHMgYXJlIGRlZXBseSBtZXJnZWRcbiAqIC0gYXJyYXlzIGFyZSBtZXJnZWQgaW4gc3VjaCBhIHdheSB0aGF0OlxuICogICAtIHdoZW4gdGhlIGFycmF5IGlzIHNldCBpbiBmb3JtIGRhdGEsIG9ubHkgYXJyYXkgZW50cmllcyBzZXQgaW4gZm9ybSBkYXRhXG4gKiAgICAgYXJlIGRlZXBseSBtZXJnZWQ7IGFkZGl0aW9uYWwgZW50cmllcyBmcm9tIHRoZSBkZWZhdWx0cyBhcmUgaWdub3JlZFxuICogICAtIHdoZW4gdGhlIGFycmF5IGlzIG5vdCBzZXQgaW4gZm9ybSBkYXRhLCB0aGUgZGVmYXVsdCBpcyBjb3BpZWQgb3ZlclxuICogLSBzY2FsYXJzIGFyZSBvdmVyd3JpdHRlbi9zZXQgYnkgZm9ybSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZmF1bHRzV2l0aEZvcm1EYXRhKGRlZmF1bHRzLCBmb3JtRGF0YSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtRGF0YSkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XG4gICAgICBkZWZhdWx0cyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybURhdGEubWFwKCh2YWx1ZSwgaWR4KSA9PiB7XG4gICAgICBpZiAoZGVmYXVsdHNbaWR4XSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0c1dpdGhGb3JtRGF0YShkZWZhdWx0c1tpZHhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZm9ybURhdGEpKSB7XG4gICAgY29uc3QgYWNjID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpOyAvLyBQcmV2ZW50IG11dGF0aW9uIG9mIHNvdXJjZSBvYmplY3QuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZvcm1EYXRhKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICBhY2Nba2V5XSA9IG1lcmdlRGVmYXVsdHNXaXRoRm9ybURhdGEoXG4gICAgICAgIGRlZmF1bHRzID8gZGVmYXVsdHNba2V5XSA6IHt9LFxuICAgICAgICBmb3JtRGF0YVtrZXldXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBhY2MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmb3JtRGF0YTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKSB7XG4gIC8vIGdldCBhbGwgcGFzc2VkIG9wdGlvbnMgZnJvbSB1aTp3aWRnZXQsIHVpOm9wdGlvbnMsIGFuZCB1aTo8b3B0aW9uTmFtZT5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHVpU2NoZW1hKVxuICAgIC5maWx0ZXIoa2V5ID0+IGtleS5pbmRleE9mKFwidWk6XCIpID09PSAwKVxuICAgIC5yZWR1Y2UoKG9wdGlvbnMsIGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB1aVNjaGVtYVtrZXldO1xuICAgICAgaWYgKGtleSA9PT0gXCJ1aTp3aWRnZXRcIiAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiU2V0dGluZyBvcHRpb25zIHZpYSB1aTp3aWRnZXQgb2JqZWN0IGlzIGRlcHJlY2F0ZWQsIHVzZSB1aTpvcHRpb25zIGluc3RlYWRcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uKHZhbHVlLm9wdGlvbnMgfHwge30pLFxuICAgICAgICAgIHdpZGdldDogdmFsdWUuY29tcG9uZW50LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gXCJ1aTpvcHRpb25zXCIgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIC4uLnZhbHVlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5vcHRpb25zLCBba2V5LnN1YnN0cmluZygzKV06IHZhbHVlIH07XG4gICAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIHJvb3RTY2hlbWEpIHtcbiAgY29uc3QgdWlPcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgbGV0IHsgbGFiZWw6IGRpc3BsYXlMYWJlbCA9IHRydWUgfSA9IHVpT3B0aW9ucztcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGUoc2NoZW1hKTtcblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgZGlzcGxheUxhYmVsID1cbiAgICAgIGlzTXVsdGlTZWxlY3Qoc2NoZW1hLCByb290U2NoZW1hKSB8fFxuICAgICAgaXNGaWxlc0FycmF5KHNjaGVtYSwgdWlTY2hlbWEsIHJvb3RTY2hlbWEpO1xuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICBkaXNwbGF5TGFiZWwgPSBmYWxzZTtcbiAgfVxuICBpZiAoc2NoZW1hVHlwZSA9PT0gXCJib29sZWFuXCIgJiYgIXVpU2NoZW1hW1widWk6d2lkZ2V0XCJdKSB7XG4gICAgZGlzcGxheUxhYmVsID0gZmFsc2U7XG4gIH1cbiAgaWYgKHVpU2NoZW1hW1widWk6ZmllbGRcIl0pIHtcbiAgICBkaXNwbGF5TGFiZWwgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGlzcGxheUxhYmVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaW5nIGluc3RhbmNlb2YgRmlsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmIHRoaW5nICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHRoaW5nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvYmoxLCBvYmoyLCBjb25jYXRBcnJheXMgPSBmYWxzZSkge1xuICAvLyBSZWN1cnNpdmVseSBtZXJnZSBkZWVwbHkgbmVzdGVkIG9iamVjdHMuXG4gIHZhciBhY2MgPSBPYmplY3QuYXNzaWduKHt9LCBvYmoxKTsgLy8gUHJldmVudCBtdXRhdGlvbiBvZiBzb3VyY2Ugb2JqZWN0LlxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqMikucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IGxlZnQgPSBvYmoxID8gb2JqMVtrZXldIDoge30sXG4gICAgICByaWdodCA9IG9iajJba2V5XTtcbiAgICBpZiAob2JqMSAmJiBvYmoxLmhhc093blByb3BlcnR5KGtleSkgJiYgaXNPYmplY3QocmlnaHQpKSB7XG4gICAgICBhY2Nba2V5XSA9IG1lcmdlT2JqZWN0cyhsZWZ0LCByaWdodCwgY29uY2F0QXJyYXlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbmNhdEFycmF5cyAmJiBBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICBhY2Nba2V5XSA9IGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjW2tleV0gPSByaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgYWNjKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKC9cXC4kLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIFwiMy5cIiBjYW4ndCByZWFsbHkgYmUgY29uc2lkZXJlZCBhIG51bWJlciBldmVuIGlmIGl0IHBhcnNlcyBpbiBqcy4gVGhlXG4gICAgLy8gdXNlciBpcyBtb3N0IGxpa2VseSBlbnRlcmluZyBhIGZsb2F0LlxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoL1xcLjAkLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIHRoaXMgYXMgYSBzdHJpbmcgaGVyZSwgdG8gYWxsb3cgZm9yIGlucHV0IGxpa2UgMy4wN1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBuID0gTnVtYmVyKHZhbHVlKTtcbiAgY29uc3QgdmFsaWQgPSB0eXBlb2YgbiA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKG4pO1xuXG4gIGlmICgvXFwuXFxkKjAkLy50ZXN0KHZhbHVlKSkge1xuICAgIC8vIEl0J3MgYSBudW1iZXIsIHRoYXQncyBjb29sIC0gYnV0IHdlIG5lZWQgaXQgYXMgYSBzdHJpbmcgc28gaXQgZG9lc24ndCBzY3Jld1xuICAgIC8vIHdpdGggdGhlIHVzZXIgd2hlbiBlbnRlcmluZyBkb2xsYXIgYW1vdW50cyBvciBvdGhlciB2YWx1ZXMgKHN1Y2ggYXMgdGhvc2Ugd2l0aFxuICAgIC8vIHNwZWNpZmljIHByZWNpc2lvbiBvciBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZCA/IG4gOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZGVyUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBvcmRlcikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cblxuICBjb25zdCBhcnJheVRvSGFzaCA9IGFyciA9PlxuICAgIGFyci5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgIHByZXZbY3Vycl0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICBjb25zdCBlcnJvclByb3BMaXN0ID0gYXJyID0+XG4gICAgYXJyLmxlbmd0aCA+IDFcbiAgICAgID8gYHByb3BlcnRpZXMgJyR7YXJyLmpvaW4oXCInLCAnXCIpfSdgXG4gICAgICA6IGBwcm9wZXJ0eSAnJHthcnJbMF19J2A7XG4gIGNvbnN0IHByb3BlcnR5SGFzaCA9IGFycmF5VG9IYXNoKHByb3BlcnRpZXMpO1xuICBjb25zdCBvcmRlckZpbHRlcmVkID0gb3JkZXIuZmlsdGVyKFxuICAgIHByb3AgPT4gcHJvcCA9PT0gXCIqXCIgfHwgcHJvcGVydHlIYXNoW3Byb3BdXG4gICk7XG4gIGNvbnN0IG9yZGVySGFzaCA9IGFycmF5VG9IYXNoKG9yZGVyRmlsdGVyZWQpO1xuXG4gIGNvbnN0IHJlc3QgPSBwcm9wZXJ0aWVzLmZpbHRlcihwcm9wID0+ICFvcmRlckhhc2hbcHJvcF0pO1xuICBjb25zdCByZXN0SW5kZXggPSBvcmRlckZpbHRlcmVkLmluZGV4T2YoXCIqXCIpO1xuICBpZiAocmVzdEluZGV4ID09PSAtMSkge1xuICAgIGlmIChyZXN0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgdWlTY2hlbWEgb3JkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluICR7ZXJyb3JQcm9wTGlzdChyZXN0KX1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXJGaWx0ZXJlZDtcbiAgfVxuICBpZiAocmVzdEluZGV4ICE9PSBvcmRlckZpbHRlcmVkLmxhc3RJbmRleE9mKFwiKlwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVpU2NoZW1hIG9yZGVyIGxpc3QgY29udGFpbnMgbW9yZSB0aGFuIG9uZSB3aWxkY2FyZCBpdGVtXCIpO1xuICB9XG5cbiAgY29uc3QgY29tcGxldGUgPSBbLi4ub3JkZXJGaWx0ZXJlZF07XG4gIGNvbXBsZXRlLnNwbGljZShyZXN0SW5kZXgsIDEsIC4uLnJlc3QpO1xuICByZXR1cm4gY29tcGxldGU7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIGdpdmVuIHNjaGVtYSBtYXRjaGVzIGEgc2luZ2xlXG4gKiBjb25zdGFudCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uc3RhbnQoc2NoZW1hKSB7XG4gIHJldHVybiAoXG4gICAgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pICYmIHNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSkgfHxcbiAgICBzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJjb25zdFwiKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Db25zdGFudChzY2hlbWEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pICYmIHNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzY2hlbWEuZW51bVswXTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJjb25zdFwiKSkge1xuICAgIHJldHVybiBzY2hlbWEuY29uc3Q7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIGNhbm5vdCBiZSBpbmZlcnJlZCBhcyBhIGNvbnN0YW50XCIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NlbGVjdChfc2NoZW1hLCByb290U2NoZW1hID0ge30pIHtcbiAgY29uc3Qgc2NoZW1hID0gcmV0cmlldmVTY2hlbWEoX3NjaGVtYSwgcm9vdFNjaGVtYSk7XG4gIGNvbnN0IGFsdFNjaGVtYXMgPSBzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mO1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFsdFNjaGVtYXMpKSB7XG4gICAgcmV0dXJuIGFsdFNjaGVtYXMuZXZlcnkoYWx0U2NoZW1hcyA9PiBpc0NvbnN0YW50KGFsdFNjaGVtYXMpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc011bHRpU2VsZWN0KHNjaGVtYSwgcm9vdFNjaGVtYSA9IHt9KSB7XG4gIGlmICghc2NoZW1hLnVuaXF1ZUl0ZW1zIHx8ICFzY2hlbWEuaXRlbXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzU2VsZWN0KHNjaGVtYS5pdGVtcywgcm9vdFNjaGVtYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVzQXJyYXkoc2NoZW1hLCB1aVNjaGVtYSwgcm9vdFNjaGVtYSA9IHt9KSB7XG4gIGlmICh1aVNjaGVtYVtcInVpOndpZGdldFwiXSA9PT0gXCJmaWxlc1wiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLml0ZW1zKSB7XG4gICAgY29uc3QgaXRlbXNTY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShzY2hlbWEuaXRlbXMsIHJvb3RTY2hlbWEpO1xuICAgIHJldHVybiBpdGVtc1NjaGVtYS50eXBlID09PSBcInN0cmluZ1wiICYmIGl0ZW1zU2NoZW1hLmZvcm1hdCA9PT0gXCJkYXRhLXVybFwiO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRml4ZWRJdGVtcyhzY2hlbWEpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgJiZcbiAgICBzY2hlbWEuaXRlbXMubGVuZ3RoID4gMCAmJlxuICAgIHNjaGVtYS5pdGVtcy5ldmVyeShpdGVtID0+IGlzT2JqZWN0KGl0ZW0pKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsb3dBZGRpdGlvbmFsSXRlbXMoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSB0cnVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiYWRkaXRpb25hbEl0ZW1zPXRydWUgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uc0xpc3Qoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZW51bSkge1xuICAgIHJldHVybiBzY2hlbWEuZW51bS5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IChzY2hlbWEuZW51bU5hbWVzICYmIHNjaGVtYS5lbnVtTmFtZXNbaV0pIHx8IFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4geyBsYWJlbCwgdmFsdWUgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhbHRTY2hlbWFzID0gc2NoZW1hLm9uZU9mIHx8IHNjaGVtYS5hbnlPZjtcbiAgICByZXR1cm4gYWx0U2NoZW1hcy5tYXAoKHNjaGVtYSwgaSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0b0NvbnN0YW50KHNjaGVtYSk7XG4gICAgICBjb25zdCBsYWJlbCA9IHNjaGVtYS50aXRsZSB8fCBTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kU2NoZW1hRGVmaW5pdGlvbigkcmVmLCByb290U2NoZW1hID0ge30pIHtcbiAgY29uc3Qgb3JpZ1JlZiA9ICRyZWY7XG4gIGlmICgkcmVmLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgLy8gRGVjb2RlIFVSSSBmcmFnbWVudCByZXByZXNlbnRhdGlvbi5cbiAgICAkcmVmID0gZGVjb2RlVVJJQ29tcG9uZW50KCRyZWYuc3Vic3RyaW5nKDEpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmaW5pdGlvbiBmb3IgJHtvcmlnUmVmfS5gKTtcbiAgfVxuICBjb25zdCBjdXJyZW50ID0ganNvbnBvaW50ZXIuZ2V0KHJvb3RTY2hlbWEsICRyZWYpO1xuICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIGRlZmluaXRpb24gZm9yICR7b3JpZ1JlZn0uYCk7XG4gIH1cbiAgaWYgKGN1cnJlbnQuaGFzT3duUHJvcGVydHkoXCIkcmVmXCIpKSB7XG4gICAgcmV0dXJuIGZpbmRTY2hlbWFEZWZpbml0aW9uKGN1cnJlbnQuJHJlZiwgcm9vdFNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8vIEluIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgdG8gaW1wbGljaXRseSBjcmVhdGUgYSBzY2hlbWEsIGl0IGlzIHVzZWZ1bCB0byBrbm93IHdoYXQgdHlwZSB0byB1c2Vcbi8vICBiYXNlZCBvbiB0aGUgZGF0YSB3ZSBhcmUgZGVmaW5pbmdcbmV4cG9ydCBjb25zdCBndWVzc1R5cGUgPSBmdW5jdGlvbiBndWVzc1R5cGUodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBcIm9iamVjdFwiO1xuICB9XG4gIC8vIERlZmF1bHQgdG8gc3RyaW5nIGlmIHdlIGNhbid0IGZpZ3VyZSBpdCBvdXRcbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIG5ldyBcInByb3BlcnRpZXNcIiBpdGVtcyBmb3IgZWFjaCBrZXkgaW4gb3VyIGZvcm1EYXRhXG5leHBvcnQgZnVuY3Rpb24gc3R1YkV4aXN0aW5nQWRkaXRpb25hbFByb3BlcnRpZXMoXG4gIHNjaGVtYSxcbiAgcm9vdFNjaGVtYSA9IHt9LFxuICBmb3JtRGF0YSA9IHt9XG4pIHtcbiAgLy8gQ2xvbmUgdGhlIHNjaGVtYSBzbyB3ZSBkb24ndCBydWluIHRoZSBjb25zdW1lcidzIG9yaWdpbmFsXG4gIHNjaGVtYSA9IHtcbiAgICAuLi5zY2hlbWEsXG4gICAgcHJvcGVydGllczogeyAuLi5zY2hlbWEucHJvcGVydGllcyB9LFxuICB9O1xuXG4gIE9iamVjdC5rZXlzKGZvcm1EYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gc3R1Yiwgb3VyIHNjaGVtYSBhbHJlYWR5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcIiRyZWZcIikpIHtcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcmV0cmlldmVTY2hlbWEoXG4gICAgICAgIHsgJHJlZjogc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzW1wiJHJlZlwiXSB9LFxuICAgICAgICByb290U2NoZW1hLFxuICAgICAgICBmb3JtRGF0YVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0geyAuLi5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXMgPSB7IHR5cGU6IGd1ZXNzVHlwZShmb3JtRGF0YVtrZXldKSB9O1xuICAgIH1cblxuICAgIC8vIFRoZSB0eXBlIG9mIG91ciBuZXcga2V5IHNob3VsZCBtYXRjaCB0aGUgYWRkaXRpb25hbFByb3BlcnRpZXMgdmFsdWU7XG4gICAgc2NoZW1hLnByb3BlcnRpZXNba2V5XSA9IGFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgIC8vIFNldCBvdXIgYWRkaXRpb25hbCBwcm9wZXJ0eSBmbGFnIHNvIHdlIGtub3cgaXQgd2FzIGR5bmFtaWNhbGx5IGFkZGVkXG4gICAgc2NoZW1hLnByb3BlcnRpZXNba2V5XVtBRERJVElPTkFMX1BST1BFUlRZX0ZMQUddID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVTY2hlbWEoc2NoZW1hLCByb290U2NoZW1hID0ge30sIGZvcm1EYXRhID0ge30pIHtcbiAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcIiRyZWZcIikpIHtcbiAgICByZXR1cm4gcmVzb2x2ZVJlZmVyZW5jZShzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJkZXBlbmRlbmNpZXNcIikpIHtcbiAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IHJlc29sdmVEZXBlbmRlbmNpZXMoc2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gICAgcmV0dXJuIHJldHJpZXZlU2NoZW1hKHJlc29sdmVkU2NoZW1hLCByb290U2NoZW1hLCBmb3JtRGF0YSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KFwiYWxsT2ZcIikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2NoZW1hLFxuICAgICAgYWxsT2Y6IHNjaGVtYS5hbGxPZi5tYXAoYWxsT2ZTdWJzY2hlbWEgPT5cbiAgICAgICAgcmV0cmlldmVTY2hlbWEoYWxsT2ZTdWJzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKVxuICAgICAgKSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vICRyZWYgb3IgZGVwZW5kZW5jaWVzIGF0dHJpYnV0ZSBmb3VuZCwgcmV0dXJuaW5nIHRoZSBvcmlnaW5hbCBzY2hlbWEuXG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVmZXJlbmNlKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpIHtcbiAgLy8gUmV0cmlldmUgdGhlIHJlZmVyZW5jZWQgc2NoZW1hIGRlZmluaXRpb24uXG4gIGNvbnN0ICRyZWZTY2hlbWEgPSBmaW5kU2NoZW1hRGVmaW5pdGlvbihzY2hlbWEuJHJlZiwgcm9vdFNjaGVtYSk7XG4gIC8vIERyb3AgdGhlICRyZWYgcHJvcGVydHkgb2YgdGhlIHNvdXJjZSBzY2hlbWEuXG4gIGNvbnN0IHsgJHJlZiwgLi4ubG9jYWxTY2hlbWEgfSA9IHNjaGVtYTtcbiAgLy8gVXBkYXRlIHJlZmVyZW5jZWQgc2NoZW1hIGRlZmluaXRpb24gd2l0aCBsb2NhbCBzY2hlbWEgcHJvcGVydGllcy5cbiAgcmV0dXJuIHJldHJpZXZlU2NoZW1hKFxuICAgIHsgLi4uJHJlZlNjaGVtYSwgLi4ubG9jYWxTY2hlbWEgfSxcbiAgICByb290U2NoZW1hLFxuICAgIGZvcm1EYXRhXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXRyaWV2ZVNjaGVtYShzY2hlbWEsIHJvb3RTY2hlbWEgPSB7fSwgZm9ybURhdGEgPSB7fSkge1xuICBpZiAoIWlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgbGV0IHJlc29sdmVkU2NoZW1hID0gcmVzb2x2ZVNjaGVtYShzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgaWYgKFwiYWxsT2ZcIiBpbiBzY2hlbWEpIHtcbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZWRTY2hlbWEgPSBtZXJnZUFsbE9mKHtcbiAgICAgICAgLi4ucmVzb2x2ZWRTY2hlbWEsXG4gICAgICAgIGFsbE9mOiByZXNvbHZlZFNjaGVtYS5hbGxPZixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihcImNvdWxkIG5vdCBtZXJnZSBzdWJzY2hlbWFzIGluIGFsbE9mOlxcblwiICsgZSk7XG4gICAgICBjb25zdCB7IGFsbE9mLCAuLi5yZXNvbHZlZFNjaGVtYVdpdGhvdXRBbGxPZiB9ID0gcmVzb2x2ZWRTY2hlbWE7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWFXaXRob3V0QWxsT2Y7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc0FkZGl0aW9uYWxQcm9wZXJ0aWVzID1cbiAgICByZXNvbHZlZFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpICYmXG4gICAgcmVzb2x2ZWRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgIT09IGZhbHNlO1xuICBpZiAoaGFzQWRkaXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gc3R1YkV4aXN0aW5nQWRkaXRpb25hbFByb3BlcnRpZXMoXG4gICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVwZW5kZW5jaWVzKHNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpIHtcbiAgLy8gRHJvcCB0aGUgZGVwZW5kZW5jaWVzIGZyb20gdGhlIHNvdXJjZSBzY2hlbWEuXG4gIGxldCB7IGRlcGVuZGVuY2llcyA9IHt9LCAuLi5yZXNvbHZlZFNjaGVtYSB9ID0gc2NoZW1hO1xuICBpZiAoXCJvbmVPZlwiIGluIHJlc29sdmVkU2NoZW1hKSB7XG4gICAgcmVzb2x2ZWRTY2hlbWEgPVxuICAgICAgcmVzb2x2ZWRTY2hlbWEub25lT2ZbXG4gICAgICAgIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCByZXNvbHZlZFNjaGVtYS5vbmVPZiwgcm9vdFNjaGVtYSlcbiAgICAgIF07XG4gIH0gZWxzZSBpZiAoXCJhbnlPZlwiIGluIHJlc29sdmVkU2NoZW1hKSB7XG4gICAgcmVzb2x2ZWRTY2hlbWEgPVxuICAgICAgcmVzb2x2ZWRTY2hlbWEuYW55T2ZbXG4gICAgICAgIGdldE1hdGNoaW5nT3B0aW9uKGZvcm1EYXRhLCByZXNvbHZlZFNjaGVtYS5hbnlPZiwgcm9vdFNjaGVtYSlcbiAgICAgIF07XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NEZXBlbmRlbmNpZXMoXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIHJlc29sdmVkU2NoZW1hLFxuICAgIHJvb3RTY2hlbWEsXG4gICAgZm9ybURhdGFcbiAgKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NEZXBlbmRlbmNpZXMoXG4gIGRlcGVuZGVuY2llcyxcbiAgcmVzb2x2ZWRTY2hlbWEsXG4gIHJvb3RTY2hlbWEsXG4gIGZvcm1EYXRhXG4pIHtcbiAgLy8gUHJvY2VzcyBkZXBlbmRlbmNpZXMgdXBkYXRpbmcgdGhlIGxvY2FsIHNjaGVtYSBwcm9wZXJ0aWVzIGFzIGFwcHJvcHJpYXRlLlxuICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lLZXkgaW4gZGVwZW5kZW5jaWVzKSB7XG4gICAgLy8gU2tpcCB0aGlzIGRlcGVuZGVuY3kgaWYgaXRzIHRyaWdnZXIgcHJvcGVydHkgaXMgbm90IHByZXNlbnQuXG4gICAgaWYgKGZvcm1EYXRhW2RlcGVuZGVuY3lLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBTa2lwIHRoaXMgZGVwZW5kZW5jeSBpZiBpdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHNjaGVtYSAoc3VjaCBhcyB3aGVuIGRlcGVuZGVuY3lLZXkgaXMgaXRzZWxmIGEgaGlkZGVuIGRlcGVuZGVuY3kuKVxuICAgIGlmIChcbiAgICAgIHJlc29sdmVkU2NoZW1hLnByb3BlcnRpZXMgJiZcbiAgICAgICEoZGVwZW5kZW5jeUtleSBpbiByZXNvbHZlZFNjaGVtYS5wcm9wZXJ0aWVzKVxuICAgICkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIFtkZXBlbmRlbmN5S2V5XTogZGVwZW5kZW5jeVZhbHVlLFxuICAgICAgLi4ucmVtYWluaW5nRGVwZW5kZW5jaWVzXG4gICAgfSA9IGRlcGVuZGVuY2llcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZXBlbmRlbmN5VmFsdWUpKSB7XG4gICAgICByZXNvbHZlZFNjaGVtYSA9IHdpdGhEZXBlbmRlbnRQcm9wZXJ0aWVzKHJlc29sdmVkU2NoZW1hLCBkZXBlbmRlbmN5VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVwZW5kZW5jeVZhbHVlKSkge1xuICAgICAgcmVzb2x2ZWRTY2hlbWEgPSB3aXRoRGVwZW5kZW50U2NoZW1hKFxuICAgICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGRlcGVuZGVuY3lLZXksXG4gICAgICAgIGRlcGVuZGVuY3lWYWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3NEZXBlbmRlbmNpZXMoXG4gICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMsXG4gICAgICByZXNvbHZlZFNjaGVtYSxcbiAgICAgIHJvb3RTY2hlbWEsXG4gICAgICBmb3JtRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xufVxuXG5mdW5jdGlvbiB3aXRoRGVwZW5kZW50UHJvcGVydGllcyhzY2hlbWEsIGFkZGl0aW9uYWxseVJlcXVpcmVkKSB7XG4gIGlmICghYWRkaXRpb25hbGx5UmVxdWlyZWQpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIGNvbnN0IHJlcXVpcmVkID0gQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpXG4gICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLnNjaGVtYS5yZXF1aXJlZCwgLi4uYWRkaXRpb25hbGx5UmVxdWlyZWRdKSlcbiAgICA6IGFkZGl0aW9uYWxseVJlcXVpcmVkO1xuICByZXR1cm4geyAuLi5zY2hlbWEsIHJlcXVpcmVkOiByZXF1aXJlZCB9O1xufVxuXG5mdW5jdGlvbiB3aXRoRGVwZW5kZW50U2NoZW1hKFxuICBzY2hlbWEsXG4gIHJvb3RTY2hlbWEsXG4gIGZvcm1EYXRhLFxuICBkZXBlbmRlbmN5S2V5LFxuICBkZXBlbmRlbmN5VmFsdWVcbikge1xuICBsZXQgeyBvbmVPZiwgLi4uZGVwZW5kZW50U2NoZW1hIH0gPSByZXRyaWV2ZVNjaGVtYShcbiAgICBkZXBlbmRlbmN5VmFsdWUsXG4gICAgcm9vdFNjaGVtYSxcbiAgICBmb3JtRGF0YVxuICApO1xuICBzY2hlbWEgPSBtZXJnZVNjaGVtYXMoc2NoZW1hLCBkZXBlbmRlbnRTY2hlbWEpO1xuICAvLyBTaW5jZSBpdCBkb2VzIG5vdCBjb250YWluIG9uZU9mLCB3ZSByZXR1cm4gdGhlIG9yaWdpbmFsIHNjaGVtYS5cbiAgaWYgKG9uZU9mID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG9uZU9mKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZDogaXQgaXMgc29tZSAke3R5cGVvZiBvbmVPZn0gaW5zdGVhZCBvZiBhbiBhcnJheWApO1xuICB9XG4gIC8vIFJlc29sdmUgJHJlZnMgaW5zaWRlIG9uZU9mLlxuICBjb25zdCByZXNvbHZlZE9uZU9mID0gb25lT2YubWFwKHN1YnNjaGVtYSA9PlxuICAgIHN1YnNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcIiRyZWZcIilcbiAgICAgID8gcmVzb2x2ZVJlZmVyZW5jZShzdWJzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKVxuICAgICAgOiBzdWJzY2hlbWFcbiAgKTtcbiAgcmV0dXJuIHdpdGhFeGFjdGx5T25lU3Vic2NoZW1hKFxuICAgIHNjaGVtYSxcbiAgICByb290U2NoZW1hLFxuICAgIGZvcm1EYXRhLFxuICAgIGRlcGVuZGVuY3lLZXksXG4gICAgcmVzb2x2ZWRPbmVPZlxuICApO1xufVxuXG5mdW5jdGlvbiB3aXRoRXhhY3RseU9uZVN1YnNjaGVtYShcbiAgc2NoZW1hLFxuICByb290U2NoZW1hLFxuICBmb3JtRGF0YSxcbiAgZGVwZW5kZW5jeUtleSxcbiAgb25lT2Zcbikge1xuICBjb25zdCB2YWxpZFN1YnNjaGVtYXMgPSBvbmVPZi5maWx0ZXIoc3Vic2NoZW1hID0+IHtcbiAgICBpZiAoIXN1YnNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgW2RlcGVuZGVuY3lLZXldOiBjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSB9ID0gc3Vic2NoZW1hLnByb3BlcnRpZXM7XG4gICAgaWYgKGNvbmRpdGlvblByb3BlcnR5U2NoZW1hKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25TY2hlbWEgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBbZGVwZW5kZW5jeUtleV06IGNvbmRpdGlvblByb3BlcnR5U2NoZW1hLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSB2YWxpZGF0ZUZvcm1EYXRhKGZvcm1EYXRhLCBjb25kaXRpb25TY2hlbWEpO1xuICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9KTtcbiAgaWYgKHZhbGlkU3Vic2NoZW1hcy5sZW5ndGggIT09IDEpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcImlnbm9yaW5nIG9uZU9mIGluIGRlcGVuZGVuY2llcyBiZWNhdXNlIHRoZXJlIGlzbid0IGV4YWN0bHkgb25lIHN1YnNjaGVtYSB0aGF0IGlzIHZhbGlkXCJcbiAgICApO1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgY29uc3Qgc3Vic2NoZW1hID0gdmFsaWRTdWJzY2hlbWFzWzBdO1xuICBjb25zdCB7XG4gICAgW2RlcGVuZGVuY3lLZXldOiBjb25kaXRpb25Qcm9wZXJ0eVNjaGVtYSxcbiAgICAuLi5kZXBlbmRlbnRTdWJzY2hlbWFcbiAgfSA9IHN1YnNjaGVtYS5wcm9wZXJ0aWVzO1xuICBjb25zdCBkZXBlbmRlbnRTY2hlbWEgPSB7IC4uLnN1YnNjaGVtYSwgcHJvcGVydGllczogZGVwZW5kZW50U3Vic2NoZW1hIH07XG4gIHJldHVybiBtZXJnZVNjaGVtYXMoXG4gICAgc2NoZW1hLFxuICAgIHJldHJpZXZlU2NoZW1hKGRlcGVuZGVudFNjaGVtYSwgcm9vdFNjaGVtYSwgZm9ybURhdGEpXG4gICk7XG59XG5cbi8vIFJlY3Vyc2l2ZWx5IG1lcmdlIGRlZXBseSBuZXN0ZWQgc2NoZW1hcy5cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gbWVyZ2VTY2hlbWFzIGFuZCBtZXJnZU9iamVjdHNcbi8vIGlzIHRoYXQgbWVyZ2VTY2hlbWFzIG9ubHkgY29uY2F0cyBhcnJheXMgZm9yXG4vLyB2YWx1ZXMgdW5kZXIgdGhlIFwicmVxdWlyZWRcIiBrZXl3b3JkLCBhbmQgd2hlbiBpdCBkb2VzLFxuLy8gaXQgZG9lc24ndCBpbmNsdWRlIGR1cGxpY2F0ZSB2YWx1ZXMuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTY2hlbWFzKG9iajEsIG9iajIpIHtcbiAgdmFyIGFjYyA9IE9iamVjdC5hc3NpZ24oe30sIG9iajEpOyAvLyBQcmV2ZW50IG11dGF0aW9uIG9mIHNvdXJjZSBvYmplY3QuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmoyKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IG9iajEgPyBvYmoxW2tleV0gOiB7fSxcbiAgICAgIHJpZ2h0ID0gb2JqMltrZXldO1xuICAgIGlmIChvYmoxICYmIG9iajEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpc09iamVjdChyaWdodCkpIHtcbiAgICAgIGFjY1trZXldID0gbWVyZ2VTY2hlbWFzKGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgb2JqMSAmJlxuICAgICAgb2JqMiAmJlxuICAgICAgKGdldFNjaGVtYVR5cGUob2JqMSkgPT09IFwib2JqZWN0XCIgfHwgZ2V0U2NoZW1hVHlwZShvYmoyKSA9PT0gXCJvYmplY3RcIikgJiZcbiAgICAgIGtleSA9PT0gXCJyZXF1aXJlZFwiICYmXG4gICAgICBBcnJheS5pc0FycmF5KGxlZnQpICYmXG4gICAgICBBcnJheS5pc0FycmF5KHJpZ2h0KVxuICAgICkge1xuICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBkdXBsaWNhdGUgdmFsdWVzIHdoZW4gbWVyZ2luZ1xuICAgICAgLy8gXCJyZXF1aXJlZFwiIGZpZWxkcy5cbiAgICAgIGFjY1trZXldID0gdW5pb24obGVmdCwgcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nba2V5XSA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBhY2MpO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVlcEVxdWFscyhhLCBiLCBjYSA9IFtdLCBjYiA9IFtdKSB7XG4gIC8vIFBhcnRpYWxseSBleHRyYWN0ZWQgZnJvbSBub2RlLWRlZXBlciBhbmQgYWRhcHRlZCB0byBleGNsdWRlIGNvbXBhcmlzb25cbiAgLy8gY2hlY2tzIGZvciBmdW5jdGlvbnMuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vdGhpeW0yMy9ub2RlLWRlZXBlclxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIEFzc3VtZSBhbGwgZnVuY3Rpb25zIGFyZSBlcXVpdmFsZW50XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yanNmLXRlYW0vcmVhY3QtanNvbnNjaGVtYS1mb3JtL2lzc3Vlcy8yNTVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHAgJiYgYiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiZcbiAgICAgIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJlxuICAgICAgYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lICYmXG4gICAgICBhLmxhc3RJbmRleCA9PT0gYi5sYXN0SW5kZXggJiZcbiAgICAgIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc0FyZ3VtZW50cyhhKSB8fCBpc0FyZ3VtZW50cyhiKSkge1xuICAgIGlmICghKGlzQXJndW1lbnRzKGEpICYmIGlzQXJndW1lbnRzKGIpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgcmV0dXJuIGRlZXBFcXVhbHMoc2xpY2UuY2FsbChhKSwgc2xpY2UuY2FsbChiKSwgY2EsIGNiKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBrYSA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxldCBrYiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIC8vIGRvbid0IGJvdGhlciB3aXRoIHN0YWNrIGFjcm9iYXRpY3MgaWYgdGhlcmUncyBub3RoaW5nIHRoZXJlXG4gICAgaWYgKGthLmxlbmd0aCA9PT0gMCAmJiBrYi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY2FsID0gY2EubGVuZ3RoO1xuICAgIHdoaWxlIChjYWwtLSkge1xuICAgICAgaWYgKGNhW2NhbF0gPT09IGEpIHtcbiAgICAgICAgcmV0dXJuIGNiW2NhbF0gPT09IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGNhLnB1c2goYSk7XG4gICAgY2IucHVzaChiKTtcblxuICAgIGthLnNvcnQoKTtcbiAgICBrYi5zb3J0KCk7XG4gICAgZm9yICh2YXIgaiA9IGthLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoa2Fbal0gIT09IGtiW2pdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGsgPSBrYS5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xuICAgICAga2V5ID0ga2Fba107XG4gICAgICBpZiAoIWRlZXBFcXVhbHMoYVtrZXldLCBiW2tleV0sIGNhLCBjYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhLnBvcCgpO1xuICAgIGNiLnBvcCgpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFJlbmRlcihjb21wLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICBjb25zdCB7IHByb3BzLCBzdGF0ZSB9ID0gY29tcDtcbiAgcmV0dXJuICFkZWVwRXF1YWxzKHByb3BzLCBuZXh0UHJvcHMpIHx8ICFkZWVwRXF1YWxzKHN0YXRlLCBuZXh0U3RhdGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9JZFNjaGVtYShcbiAgc2NoZW1hLFxuICBpZCxcbiAgcm9vdFNjaGVtYSxcbiAgZm9ybURhdGEgPSB7fSxcbiAgaWRQcmVmaXggPSBcInJvb3RcIlxuKSB7XG4gIGNvbnN0IGlkU2NoZW1hID0ge1xuICAgICRpZDogaWQgfHwgaWRQcmVmaXgsXG4gIH07XG4gIGlmIChcIiRyZWZcIiBpbiBzY2hlbWEgfHwgXCJkZXBlbmRlbmNpZXNcIiBpbiBzY2hlbWEgfHwgXCJhbGxPZlwiIGluIHNjaGVtYSkge1xuICAgIGNvbnN0IF9zY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICByZXR1cm4gdG9JZFNjaGVtYShfc2NoZW1hLCBpZCwgcm9vdFNjaGVtYSwgZm9ybURhdGEsIGlkUHJlZml4KTtcbiAgfVxuICBpZiAoXCJpdGVtc1wiIGluIHNjaGVtYSAmJiAhc2NoZW1hLml0ZW1zLiRyZWYpIHtcbiAgICByZXR1cm4gdG9JZFNjaGVtYShzY2hlbWEuaXRlbXMsIGlkLCByb290U2NoZW1hLCBmb3JtRGF0YSwgaWRQcmVmaXgpO1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBpZFNjaGVtYTtcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMgfHwge30pIHtcbiAgICBjb25zdCBmaWVsZCA9IHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIGNvbnN0IGZpZWxkSWQgPSBpZFNjaGVtYS4kaWQgKyBcIl9cIiArIG5hbWU7XG4gICAgaWRTY2hlbWFbbmFtZV0gPSB0b0lkU2NoZW1hKFxuICAgICAgaXNPYmplY3QoZmllbGQpID8gZmllbGQgOiB7fSxcbiAgICAgIGZpZWxkSWQsXG4gICAgICByb290U2NoZW1hLFxuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGZvcm1EYXRhIGlzIG5vdCBhbiBvYmplY3QgLS0gdGhpcyBjYW4gaGFwcGVuIGlmIGFuXG4gICAgICAvLyBhcnJheSBpdGVtIGhhcyBqdXN0IGJlZW4gYWRkZWQsIGJ1dCBub3QgcG9wdWxhdGVkIHdpdGggZGF0YSB5ZXRcbiAgICAgIChmb3JtRGF0YSB8fCB7fSlbbmFtZV0sXG4gICAgICBpZFByZWZpeFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGlkU2NoZW1hO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QYXRoU2NoZW1hKHNjaGVtYSwgbmFtZSA9IFwiXCIsIHJvb3RTY2hlbWEsIGZvcm1EYXRhID0ge30pIHtcbiAgY29uc3QgcGF0aFNjaGVtYSA9IHtcbiAgICAkbmFtZTogbmFtZS5yZXBsYWNlKC9eXFwuLywgXCJcIiksXG4gIH07XG4gIGlmIChcIiRyZWZcIiBpbiBzY2hlbWEgfHwgXCJkZXBlbmRlbmNpZXNcIiBpbiBzY2hlbWEgfHwgXCJhbGxPZlwiIGluIHNjaGVtYSkge1xuICAgIGNvbnN0IF9zY2hlbWEgPSByZXRyaWV2ZVNjaGVtYShzY2hlbWEsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgICByZXR1cm4gdG9QYXRoU2NoZW1hKF9zY2hlbWEsIG5hbWUsIHJvb3RTY2hlbWEsIGZvcm1EYXRhKTtcbiAgfVxuXG4gIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSkge1xuICAgIHBhdGhTY2hlbWEuX19yanNmX2FkZGl0aW9uYWxQcm9wZXJ0aWVzID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoXCJpdGVtc1wiKSAmJiBBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgIGZvcm1EYXRhLmZvckVhY2goKGVsZW1lbnQsIGkpID0+IHtcbiAgICAgIHBhdGhTY2hlbWFbaV0gPSB0b1BhdGhTY2hlbWEoXG4gICAgICAgIHNjaGVtYS5pdGVtcyxcbiAgICAgICAgYCR7bmFtZX0uJHtpfWAsXG4gICAgICAgIHJvb3RTY2hlbWEsXG4gICAgICAgIGVsZW1lbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KFwicHJvcGVydGllc1wiKSkge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHBhdGhTY2hlbWFbcHJvcGVydHldID0gdG9QYXRoU2NoZW1hKFxuICAgICAgICBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV0sXG4gICAgICAgIGAke25hbWV9LiR7cHJvcGVydHl9YCxcbiAgICAgICAgcm9vdFNjaGVtYSxcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGZvcm1EYXRhIGlzIG5vdCBhbiBvYmplY3QgLS0gdGhpcyBjYW4gaGFwcGVuIGlmIGFuXG4gICAgICAgIC8vIGFycmF5IGl0ZW0gaGFzIGp1c3QgYmVlbiBhZGRlZCwgYnV0IG5vdCBwb3B1bGF0ZWQgd2l0aCBkYXRhIHlldFxuICAgICAgICAoZm9ybURhdGEgfHwge30pW3Byb3BlcnR5XVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGhTY2hlbWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGVTdHJpbmcoZGF0ZVN0cmluZywgaW5jbHVkZVRpbWUgPSB0cnVlKSB7XG4gIGlmICghZGF0ZVN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICB5ZWFyOiAtMSxcbiAgICAgIG1vbnRoOiAtMSxcbiAgICAgIGRheTogLTEsXG4gICAgICBob3VyOiBpbmNsdWRlVGltZSA/IC0xIDogMCxcbiAgICAgIG1pbnV0ZTogaW5jbHVkZVRpbWUgPyAtMSA6IDAsXG4gICAgICBzZWNvbmQ6IGluY2x1ZGVUaW1lID8gLTEgOiAwLFxuICAgIH07XG4gIH1cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICBpZiAoTnVtYmVyLmlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwYXJzZSBkYXRlIFwiICsgZGF0ZVN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbW9udGg6IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsIC8vIG9oIHlvdSwgamF2YXNjcmlwdC5cbiAgICBkYXk6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGluY2x1ZGVUaW1lID8gZGF0ZS5nZXRVVENIb3VycygpIDogMCxcbiAgICBtaW51dGU6IGluY2x1ZGVUaW1lID8gZGF0ZS5nZXRVVENNaW51dGVzKCkgOiAwLFxuICAgIHNlY29uZDogaW5jbHVkZVRpbWUgPyBkYXRlLmdldFVUQ1NlY29uZHMoKSA6IDAsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0RhdGVTdHJpbmcoXG4gIHsgeWVhciwgbW9udGgsIGRheSwgaG91ciA9IDAsIG1pbnV0ZSA9IDAsIHNlY29uZCA9IDAgfSxcbiAgdGltZSA9IHRydWVcbikge1xuICBjb25zdCB1dGNUaW1lID0gRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcbiAgY29uc3QgZGF0ZXRpbWUgPSBuZXcgRGF0ZSh1dGNUaW1lKS50b0pTT04oKTtcbiAgcmV0dXJuIHRpbWUgPyBkYXRldGltZSA6IGRhdGV0aW1lLnNsaWNlKDAsIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHV0Y1RvTG9jYWwoanNvbkRhdGUpIHtcbiAgaWYgKCFqc29uRGF0ZSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLy8gcmVxdWlyZWQgZm9ybWF0IG9mIGBcInl5eXktTU0tZGRUaGg6bW1cIiBmb2xsb3dlZCBieSBvcHRpb25hbCBcIjpzc1wiIG9yIFwiOnNzLlNTU1wiXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2lucHV0Lmh0bWwjbG9jYWwtZGF0ZS1hbmQtdGltZS1zdGF0ZS0odHlwZSUzRGRhdGV0aW1lLWxvY2FsKVxuICAvLyA+IHNob3VsZCBiZSBhIF92YWxpZCBsb2NhbCBkYXRlIGFuZCB0aW1lIHN0cmluZ18gKG5vdCBHTVQpXG5cbiAgLy8gTm90ZSAtIGRhdGUgY29uc3RydWN0b3IgcGFzc2VkIGxvY2FsIElTTy04NjAxIGRvZXMgbm90IGNvcnJlY3RseVxuICAvLyBjaGFuZ2UgdGltZSB0byBVVEMgaW4gbm9kZSBwcmUtOFxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoanNvbkRhdGUpO1xuXG4gIGNvbnN0IHl5eXkgPSBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcbiAgY29uc3QgTU0gPSBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gIGNvbnN0IGRkID0gcGFkKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgY29uc3QgaGggPSBwYWQoZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgY29uc3QgbW0gPSBwYWQoZGF0ZS5nZXRNaW51dGVzKCksIDIpO1xuICBjb25zdCBzcyA9IHBhZChkYXRlLmdldFNlY29uZHMoKSwgMik7XG4gIGNvbnN0IFNTUyA9IHBhZChkYXRlLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcblxuICByZXR1cm4gYCR7eXl5eX0tJHtNTX0tJHtkZH1UJHtoaH06JHttbX06JHtzc30uJHtTU1N9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsVG9VVEMoZGF0ZVN0cmluZykge1xuICBpZiAoZGF0ZVN0cmluZykge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlU3RyaW5nKS50b0pTT04oKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkKG51bSwgc2l6ZSkge1xuICBsZXQgcyA9IFN0cmluZyhudW0pO1xuICB3aGlsZSAocy5sZW5ndGggPCBzaXplKSB7XG4gICAgcyA9IFwiMFwiICsgcztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFVUkl0b0Jsb2IoZGF0YVVSSSkge1xuICAvLyBTcGxpdCBtZXRhZGF0YSBmcm9tIGRhdGFcbiAgY29uc3Qgc3BsaXR0ZWQgPSBkYXRhVVJJLnNwbGl0KFwiLFwiKTtcbiAgLy8gU3BsaXQgcGFyYW1zXG4gIGNvbnN0IHBhcmFtcyA9IHNwbGl0dGVkWzBdLnNwbGl0KFwiO1wiKTtcbiAgLy8gR2V0IG1pbWUtdHlwZSBmcm9tIHBhcmFtc1xuICBjb25zdCB0eXBlID0gcGFyYW1zWzBdLnJlcGxhY2UoXCJkYXRhOlwiLCBcIlwiKTtcbiAgLy8gRmlsdGVyIHRoZSBuYW1lIHByb3BlcnR5IGZyb20gcGFyYW1zXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBwYXJhbXMuZmlsdGVyKHBhcmFtID0+IHtcbiAgICByZXR1cm4gcGFyYW0uc3BsaXQoXCI9XCIpWzBdID09PSBcIm5hbWVcIjtcbiAgfSk7XG4gIC8vIExvb2sgZm9yIHRoZSBuYW1lIGFuZCB1c2UgdW5rbm93biBpZiBubyBuYW1lIHByb3BlcnR5LlxuICBsZXQgbmFtZTtcbiAgaWYgKHByb3BlcnRpZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgbmFtZSA9IFwidW5rbm93blwiO1xuICB9IGVsc2Uge1xuICAgIC8vIEJlY2F1c2Ugd2UgZmlsdGVyZWQgb3V0IHRoZSBvdGhlciBwcm9wZXJ0eSxcbiAgICAvLyB3ZSBvbmx5IGhhdmUgdGhlIG5hbWUgY2FzZSBoZXJlLlxuICAgIG5hbWUgPSBwcm9wZXJ0aWVzWzBdLnNwbGl0KFwiPVwiKVsxXTtcbiAgfVxuXG4gIC8vIEJ1aWx0IHRoZSBVaW50OEFycmF5IEJsb2IgcGFyYW1ldGVyIGZyb20gdGhlIGJhc2U2NCBzdHJpbmcuXG4gIGNvbnN0IGJpbmFyeSA9IGF0b2Ioc3BsaXR0ZWRbMV0pO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5LnB1c2goYmluYXJ5LmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIC8vIENyZWF0ZSB0aGUgYmxvYiBvYmplY3RcbiAgY29uc3QgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXSwgeyB0eXBlIH0pO1xuXG4gIHJldHVybiB7IGJsb2IsIG5hbWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlU3BlYyhzY2hlbWEpIHtcbiAgY29uc3Qgc3BlYyA9IHt9O1xuICBpZiAoc2NoZW1hLm11bHRpcGxlT2YpIHtcbiAgICBzcGVjLnN0ZXAgPSBzY2hlbWEubXVsdGlwbGVPZjtcbiAgfVxuICBpZiAoc2NoZW1hLm1pbmltdW0gfHwgc2NoZW1hLm1pbmltdW0gPT09IDApIHtcbiAgICBzcGVjLm1pbiA9IHNjaGVtYS5taW5pbXVtO1xuICB9XG4gIGlmIChzY2hlbWEubWF4aW11bSB8fCBzY2hlbWEubWF4aW11bSA9PT0gMCkge1xuICAgIHNwZWMubWF4ID0gc2NoZW1hLm1heGltdW07XG4gIH1cbiAgcmV0dXJuIHNwZWM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXRjaGluZ09wdGlvbihmb3JtRGF0YSwgb3B0aW9ucywgcm9vdFNjaGVtYSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gICAgLy8gSWYgdGhlIHNjaGVtYSBkZXNjcmliZXMgYW4gb2JqZWN0IHRoZW4gd2UgbmVlZCB0byBhZGQgc2xpZ2h0bHkgbW9yZVxuICAgIC8vIHN0cmljdCBtYXRjaGluZyB0byB0aGUgc2NoZW1hLCBiZWNhdXNlIHVubGVzcyB0aGUgc2NoZW1hIHVzZXMgdGhlXG4gICAgLy8gXCJyZXF1aXJlc1wiIGtleXdvcmQsIGFuIG9iamVjdCB3aWxsIG1hdGNoIHRoZSBzY2hlbWEgYXMgbG9uZyBhcyBpdFxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBtYXRjaGluZyBrZXlzIHdpdGggYSBjb25mbGljdGluZyB0eXBlLiBUbyBkbyB0aGlzIHdlIHVzZSBhblxuICAgIC8vIFwiYW55T2ZcIiB3aXRoIGFuIGFycmF5IG9mIHJlcXVpcmVzLiBUaGlzIGF1Z21lbnRhdGlvbiBleHByZXNzZXMgdGhhdCB0aGVcbiAgICAvLyBzY2hlbWEgc2hvdWxkIG1hdGNoIGlmIGFueSBvZiB0aGUga2V5cyBpbiB0aGUgc2NoZW1hIGFyZSBwcmVzZW50IG9uIHRoZVxuICAgIC8vIG9iamVjdCBhbmQgcGFzcyB2YWxpZGF0aW9uLlxuICAgIGlmIChvcHRpb24ucHJvcGVydGllcykge1xuICAgICAgLy8gQ3JlYXRlIGFuIFwiYW55T2ZcIiBzY2hlbWEgdGhhdCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGtleXMgaW4gdGhlXG4gICAgICAvLyBcInByb3BlcnRpZXNcIiBvYmplY3RcbiAgICAgIGNvbnN0IHJlcXVpcmVzQW55T2YgPSB7XG4gICAgICAgIGFueU9mOiBPYmplY3Qua2V5cyhvcHRpb24ucHJvcGVydGllcykubWFwKGtleSA9PiAoe1xuICAgICAgICAgIHJlcXVpcmVkOiBba2V5XSxcbiAgICAgICAgfSkpLFxuICAgICAgfTtcblxuICAgICAgbGV0IGF1Z21lbnRlZFNjaGVtYTtcblxuICAgICAgLy8gSWYgdGhlIFwiYW55T2ZcIiBrZXl3b3JkIGFscmVhZHkgZXhpc3RzLCB3cmFwIHRoZSBhdWdtZW50YXRpb24gaW4gYW4gXCJhbGxPZlwiXG4gICAgICBpZiAob3B0aW9uLmFueU9mKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIG9wdGlvblxuICAgICAgICBjb25zdCB7IC4uLnNoYWxsb3dDbG9uZSB9ID0gb3B0aW9uO1xuXG4gICAgICAgIGlmICghc2hhbGxvd0Nsb25lLmFsbE9mKSB7XG4gICAgICAgICAgc2hhbGxvd0Nsb25lLmFsbE9mID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgXCJhbGxPZlwiIGFscmVhZHkgZXhpc3RzLCBzaGFsbG93IGNsb25lIHRoZSBhcnJheVxuICAgICAgICAgIHNoYWxsb3dDbG9uZS5hbGxPZiA9IHNoYWxsb3dDbG9uZS5hbGxPZi5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhbGxvd0Nsb25lLmFsbE9mLnB1c2gocmVxdWlyZXNBbnlPZik7XG5cbiAgICAgICAgYXVnbWVudGVkU2NoZW1hID0gc2hhbGxvd0Nsb25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVnbWVudGVkU2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uLCByZXF1aXJlc0FueU9mKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBcInJlcXVpcmVkXCIgZmllbGQgYXMgaXQncyBsaWtlbHkgdGhhdCBub3QgYWxsIGZpZWxkcyBoYXZlXG4gICAgICAvLyBiZWVuIGZpbGxlZCBpbiB5ZXQsIHdoaWNoIHdpbGwgbWVhbiB0aGF0IHRoZSBzY2hlbWEgaXMgbm90IHZhbGlkXG4gICAgICBkZWxldGUgYXVnbWVudGVkU2NoZW1hLnJlcXVpcmVkO1xuXG4gICAgICBpZiAoaXNWYWxpZChhdWdtZW50ZWRTY2hlbWEsIGZvcm1EYXRhLCByb290U2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWQob3B0aW9uLCBmb3JtRGF0YSwgcm9vdFNjaGVtYSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIGEgc2NoZW1hIHNwZWNpZmllcyB0aGF0IGEgdmFsdWUgbXVzdCBiZSB0cnVlXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUoc2NoZW1hKSB7XG4gIC8vIENoZWNrIGlmIGNvbnN0IGlzIGEgdHJ1dGh5IHZhbHVlXG4gIGlmIChzY2hlbWEuY29uc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGFuIGVudW0gaGFzIGEgc2luZ2xlIHZhbHVlIG9mIHRydWVcbiAgaWYgKHNjaGVtYS5lbnVtICYmIHNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSAmJiBzY2hlbWEuZW51bVswXSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSWYgYW55T2YgaGFzIGEgc2luZ2xlIHZhbHVlLCBldmFsdWF0ZSB0aGUgc3Vic2NoZW1hXG4gIGlmIChzY2hlbWEuYW55T2YgJiYgc2NoZW1hLmFueU9mLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZShzY2hlbWEuYW55T2ZbMF0pO1xuICB9XG5cbiAgLy8gSWYgb25lT2YgaGFzIGEgc2luZ2xlIHZhbHVlLCBldmFsdWF0ZSB0aGUgc3Vic2NoZW1hXG4gIGlmIChzY2hlbWEub25lT2YgJiYgc2NoZW1hLm9uZU9mLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZShzY2hlbWEub25lT2ZbMF0pO1xuICB9XG5cbiAgLy8gRXZhbHVhdGUgZWFjaCBzdWJzY2hlbWEgaW4gYWxsT2YsIHRvIHNlZSBpZiBvbmUgb2YgdGhlbSByZXF1aXJlcyBhIHRydWVcbiAgLy8gdmFsdWVcbiAgaWYgKHNjaGVtYS5hbGxPZikge1xuICAgIHJldHVybiBzY2hlbWEuYWxsT2Yuc29tZShzY2hlbWFSZXF1aXJlc1RydWVWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iXX0=